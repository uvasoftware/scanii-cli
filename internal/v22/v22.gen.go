// Package v22 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package v22

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	TokenScopes = "token.Scopes"
)

// AccountInfo defines model for AccountInfo.
type AccountInfo struct {
	Balance          *float32           `json:"balance,omitempty"`
	BillingEmail     *string            `json:"billing_email,omitempty"`
	CreationDate     *string            `json:"creation_date,omitempty"`
	Keys             *map[string]ApiKey `json:"keys,omitempty"`
	ModificationDate *string            `json:"modification_date,omitempty"`
	Name             *string            `json:"name,omitempty"`
	StartingBalance  *float32           `json:"starting_balance,omitempty"`
	Subscription     *string            `json:"subscription,omitempty"`
	Users            *map[string]User   `json:"users,omitempty"`
}

// ApiKey defines model for ApiKey.
type ApiKey struct {
	Active                     *bool     `json:"active,omitempty"`
	CreationDate               *string   `json:"creation_date,omitempty"`
	DetectionCategoriesEnabled *[]string `json:"detection_categories_enabled,omitempty"`
	LastSeenDate               *string   `json:"last_seen_date,omitempty"`
	Tags                       *[]string `json:"tags,omitempty"`
}

// AuthToken defines model for AuthToken.
type AuthToken struct {
	CreationDate   *string `json:"creation_date,omitempty"`
	ExpirationDate *string `json:"expiration_date,omitempty"`
	Id             *string `json:"id,omitempty"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error    *string            `json:"error"`
	Id       *string            `json:"id"`
	Metadata *map[string]string `json:"metadata,omitempty"`
}

// ProcessingPendingResponse Entity representation of a pending content analysis
type ProcessingPendingResponse struct {
	// Id This result unique identifier, should be used to retried the result of the analysis
	Id *string `json:"id,omitempty"`
}

// ProcessingResponse Entity representation the result of a file analysis. Please note that this entity is only returned for
// synchronous requests. For asynchronous requests please refer to the [Files](#tag/Files) resource.
type ProcessingResponse struct {
	// Checksum The SHA1 digest of the content processed
	Checksum *string `json:"checksum"`

	// ContentLength The length in bytes of the content processed
	ContentLength *float32 `json:"content_length"`

	// ContentType The media type of the content processed
	ContentType *string `json:"content_type"`

	// CreationDate ISO8601 time stamp of when the content was processed
	CreationDate *string `json:"creation_date"`

	// Error If an error occurred during processing this field will contain the error message. Please note that this field is only
	// present if an error occurred during processing.
	Error *string `json:"error"`

	// Findings These are the labels/findings identified by our detection engines using a dot notation for hierarchies, for
	// example: content.malicious.foo or content.malicious.bar. Please note that the actual findings will vary based
	// on the content type and the detection engines enabled for your API key.
	// As of this API version common content hierarchies include:
	//
	// * content.malicious.{{name}} - malicious content like malware and spam
	// * content.images.nsfw.{{name}} - unsafe image
	// * content.{{ISO_3166-1_alpha-2 country code}}.language.nsfw - unsafe language
	//
	// A empty findings array means that no findings were identified for the content processed and it should be considered *safe*.
	Findings *[]string `json:"findings"`

	// Id This result unique identifier, should be used to retried the result of the analysis
	Id       *string            `json:"id,omitempty"`
	Metadata *map[string]string `json:"metadata"`
}

// User defines model for User.
type User struct {
	CreationDate *string `json:"creation_date,omitempty"`
	LastLogin    *string `json:"last_login,omitempty"`
}

// N401 defines model for 401.
type N401 = ErrorResponse

// CreateTokenFormdataBody defines parameters for CreateToken.
type CreateTokenFormdataBody struct {
	// Timeout Number of seconds this token should be valid for
	Timeout *int64 `form:"timeout,omitempty" json:"timeout,omitempty"`
}

// ProcessFileMultipartBody defines parameters for ProcessFile.
type ProcessFileMultipartBody struct {
	// File File to analyze
	File openapi_types.File `json:"file"`

	// Location URL to fetch and analyze
	Location string             `json:"location"`
	Metadata *map[string]string `json:"metadata,omitempty"`
}

// ProcessFileAsyncMultipartBody defines parameters for ProcessFileAsync.
type ProcessFileAsyncMultipartBody struct {
	// Callback Callback URL to notify once processing is completed
	Callback *string `json:"callback,omitempty"`

	// File File to analyze
	File     *openapi_types.File `json:"file,omitempty"`
	Metadata *map[string]string  `json:"metadata,omitempty"`
}

// ProcessFileFetchFormdataBody defines parameters for ProcessFileFetch.
type ProcessFileFetchFormdataBody struct {
	// Callback Callback URL to notify once processing is completed
	Callback *string `form:"callback,omitempty" json:"callback,omitempty"`

	// Location URL to fetch and analyze
	Location             *string           `form:"location,omitempty" json:"location,omitempty"`
	AdditionalProperties map[string]string `json:"-"`
}

// CreateTokenFormdataRequestBody defines body for CreateToken for application/x-www-form-urlencoded ContentType.
type CreateTokenFormdataRequestBody CreateTokenFormdataBody

// ProcessFileMultipartRequestBody defines body for ProcessFile for multipart/form-data ContentType.
type ProcessFileMultipartRequestBody ProcessFileMultipartBody

// ProcessFileAsyncMultipartRequestBody defines body for ProcessFileAsync for multipart/form-data ContentType.
type ProcessFileAsyncMultipartRequestBody ProcessFileAsyncMultipartBody

// ProcessFileFetchFormdataRequestBody defines body for ProcessFileFetch for application/x-www-form-urlencoded ContentType.
type ProcessFileFetchFormdataRequestBody ProcessFileFetchFormdataBody

// Getter for additional properties for ProcessFileFetchFormdataBody. Returns the specified
// element and whether it was found
func (a ProcessFileFetchFormdataBody) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ProcessFileFetchFormdataBody
func (a *ProcessFileFetchFormdataBody) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ProcessFileFetchFormdataBody to handle AdditionalProperties
func (a *ProcessFileFetchFormdataBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["callback"]; found {
		err = json.Unmarshal(raw, &a.Callback)
		if err != nil {
			return fmt.Errorf("error reading 'callback': %w", err)
		}
		delete(object, "callback")
	}

	if raw, found := object["location"]; found {
		err = json.Unmarshal(raw, &a.Location)
		if err != nil {
			return fmt.Errorf("error reading 'location': %w", err)
		}
		delete(object, "location")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ProcessFileFetchFormdataBody to handle AdditionalProperties
func (a ProcessFileFetchFormdataBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Callback != nil {
		object["callback"], err = json.Marshal(a.Callback)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'callback': %w", err)
		}
	}

	if a.Location != nil {
		object["location"], err = json.Marshal(a.Location)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'location': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// Account request
	Account(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTokenWithBody request with any body
	CreateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTokenWithFormdataBody(ctx context.Context, body CreateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteToken request
	DeleteToken(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveToken request
	RetrieveToken(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProcessFileWithBody request with any body
	ProcessFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProcessFileAsyncWithBody request with any body
	ProcessFileAsyncWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProcessFileFetchWithBody request with any body
	ProcessFileFetchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProcessFileFetchWithFormdataBody(ctx context.Context, body ProcessFileFetchFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveFile request
	RetrieveFile(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Ping request
	Ping(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) Account(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTokenWithFormdataBody(ctx context.Context, body CreateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteToken(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTokenRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveToken(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveTokenRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProcessFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessFileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProcessFileAsyncWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessFileAsyncRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProcessFileFetchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessFileFetchRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProcessFileFetchWithFormdataBody(ctx context.Context, body ProcessFileFetchFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessFileFetchRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveFile(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveFileRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Ping(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPingRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAccountRequest generates requests for Account
func NewAccountRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/account.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTokenRequestWithFormdataBody calls the generic CreateToken builder with application/x-www-form-urlencoded body
func NewCreateTokenRequestWithFormdataBody(server string, body CreateTokenFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewCreateTokenRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewCreateTokenRequestWithBody generates requests for CreateToken with any type of body
func NewCreateTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTokenRequest generates requests for DeleteToken
func NewDeleteTokenRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/tokens/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveTokenRequest generates requests for RetrieveToken
func NewRetrieveTokenRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/tokens/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProcessFileRequestWithBody generates requests for ProcessFile with any type of body
func NewProcessFileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProcessFileAsyncRequestWithBody generates requests for ProcessFileAsync with any type of body
func NewProcessFileAsyncRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/async")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProcessFileFetchRequestWithFormdataBody calls the generic ProcessFileFetch builder with application/x-www-form-urlencoded body
func NewProcessFileFetchRequestWithFormdataBody(server string, body ProcessFileFetchFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewProcessFileFetchRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewProcessFileFetchRequestWithBody generates requests for ProcessFileFetch with any type of body
func NewProcessFileFetchRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/fetch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRetrieveFileRequest generates requests for RetrieveFile
func NewRetrieveFileRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPingRequest generates requests for Ping
func NewPingRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ping")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AccountWithResponse request
	AccountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AccountResponse, error)

	// CreateTokenWithBodyWithResponse request with any body
	CreateTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	CreateTokenWithFormdataBodyWithResponse(ctx context.Context, body CreateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	// DeleteTokenWithResponse request
	DeleteTokenWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteTokenResponse, error)

	// RetrieveTokenWithResponse request
	RetrieveTokenWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RetrieveTokenResponse, error)

	// ProcessFileWithBodyWithResponse request with any body
	ProcessFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessFileResponse, error)

	// ProcessFileAsyncWithBodyWithResponse request with any body
	ProcessFileAsyncWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessFileAsyncResponse, error)

	// ProcessFileFetchWithBodyWithResponse request with any body
	ProcessFileFetchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessFileFetchResponse, error)

	ProcessFileFetchWithFormdataBodyWithResponse(ctx context.Context, body ProcessFileFetchFormdataRequestBody, reqEditors ...RequestEditorFn) (*ProcessFileFetchResponse, error)

	// RetrieveFileWithResponse request
	RetrieveFileWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RetrieveFileResponse, error)

	// PingWithResponse request
	PingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PingResponse, error)
}

type AccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountInfo
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r AccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthToken
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r CreateTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r DeleteTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthToken
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r RetrieveTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProcessFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ProcessingResponse
	JSON400      *ErrorResponse
	JSON401      *N401
	JSON403      *ErrorResponse
	JSON413      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ProcessFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProcessFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProcessFileAsyncResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *ProcessingPendingResponse
	JSON400      *ErrorResponse
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r ProcessFileAsyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProcessFileAsyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProcessFileFetchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *ProcessingPendingResponse
	JSON400      *ErrorResponse
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r ProcessFileFetchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProcessFileFetchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProcessingResponse
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r RetrieveFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Key Returns the public key used
		Key     *string `json:"key,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r PingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AccountWithResponse request returning *AccountResponse
func (c *ClientWithResponses) AccountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AccountResponse, error) {
	rsp, err := c.Account(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountResponse(rsp)
}

// CreateTokenWithBodyWithResponse request with arbitrary body returning *CreateTokenResponse
func (c *ClientWithResponses) CreateTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateTokenWithFormdataBodyWithResponse(ctx context.Context, body CreateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateTokenWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

// DeleteTokenWithResponse request returning *DeleteTokenResponse
func (c *ClientWithResponses) DeleteTokenWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteTokenResponse, error) {
	rsp, err := c.DeleteToken(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTokenResponse(rsp)
}

// RetrieveTokenWithResponse request returning *RetrieveTokenResponse
func (c *ClientWithResponses) RetrieveTokenWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RetrieveTokenResponse, error) {
	rsp, err := c.RetrieveToken(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveTokenResponse(rsp)
}

// ProcessFileWithBodyWithResponse request with arbitrary body returning *ProcessFileResponse
func (c *ClientWithResponses) ProcessFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessFileResponse, error) {
	rsp, err := c.ProcessFileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessFileResponse(rsp)
}

// ProcessFileAsyncWithBodyWithResponse request with arbitrary body returning *ProcessFileAsyncResponse
func (c *ClientWithResponses) ProcessFileAsyncWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessFileAsyncResponse, error) {
	rsp, err := c.ProcessFileAsyncWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessFileAsyncResponse(rsp)
}

// ProcessFileFetchWithBodyWithResponse request with arbitrary body returning *ProcessFileFetchResponse
func (c *ClientWithResponses) ProcessFileFetchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessFileFetchResponse, error) {
	rsp, err := c.ProcessFileFetchWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessFileFetchResponse(rsp)
}

func (c *ClientWithResponses) ProcessFileFetchWithFormdataBodyWithResponse(ctx context.Context, body ProcessFileFetchFormdataRequestBody, reqEditors ...RequestEditorFn) (*ProcessFileFetchResponse, error) {
	rsp, err := c.ProcessFileFetchWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessFileFetchResponse(rsp)
}

// RetrieveFileWithResponse request returning *RetrieveFileResponse
func (c *ClientWithResponses) RetrieveFileWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RetrieveFileResponse, error) {
	rsp, err := c.RetrieveFile(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveFileResponse(rsp)
}

// PingWithResponse request returning *PingResponse
func (c *ClientWithResponses) PingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PingResponse, error) {
	rsp, err := c.Ping(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePingResponse(rsp)
}

// ParseAccountResponse parses an HTTP response from a AccountWithResponse call
func ParseAccountResponse(rsp *http.Response) (*AccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateTokenResponse parses an HTTP response from a CreateTokenWithResponse call
func ParseCreateTokenResponse(rsp *http.Response) (*CreateTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteTokenResponse parses an HTTP response from a DeleteTokenWithResponse call
func ParseDeleteTokenResponse(rsp *http.Response) (*DeleteTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRetrieveTokenResponse parses an HTTP response from a RetrieveTokenWithResponse call
func ParseRetrieveTokenResponse(rsp *http.Response) (*RetrieveTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseProcessFileResponse parses an HTTP response from a ProcessFileWithResponse call
func ParseProcessFileResponse(rsp *http.Response) (*ProcessFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProcessFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ProcessingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	}

	return response, nil
}

// ParseProcessFileAsyncResponse parses an HTTP response from a ProcessFileAsyncWithResponse call
func ParseProcessFileAsyncResponse(rsp *http.Response) (*ProcessFileAsyncResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProcessFileAsyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ProcessingPendingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseProcessFileFetchResponse parses an HTTP response from a ProcessFileFetchWithResponse call
func ParseProcessFileFetchResponse(rsp *http.Response) (*ProcessFileFetchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProcessFileFetchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ProcessingPendingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRetrieveFileResponse parses an HTTP response from a RetrieveFileWithResponse call
func ParseRetrieveFileResponse(rsp *http.Response) (*RetrieveFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParsePingResponse parses an HTTP response from a PingWithResponse call
func ParsePingResponse(rsp *http.Response) (*PingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Key Returns the public key used
			Key     *string `json:"key,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Retrieves account related information
	// (GET /account.json)
	Account(w http.ResponseWriter, r *http.Request)
	// Creates a temporary authentication token
	// (POST /auth/tokens)
	CreateToken(w http.ResponseWriter, r *http.Request)
	// Deletes a previously created temporary authentication token
	// (DELETE /auth/tokens/{id})
	DeleteToken(w http.ResponseWriter, r *http.Request, id string)
	// Retrieves a previously created temporary authentication token
	// (GET /auth/tokens/{id})
	RetrieveToken(w http.ResponseWriter, r *http.Request, id string)
	// Submits content for processing
	// (POST /files)
	ProcessFile(w http.ResponseWriter, r *http.Request)
	// Submits content for processing asynchronously
	// (POST /files/async)
	ProcessFileAsync(w http.ResponseWriter, r *http.Request)
	// Submits a URL for processing asynchronously
	// (POST /files/fetch)
	ProcessFileFetch(w http.ResponseWriter, r *http.Request)
	// Retrieves a previously created processing result
	// (GET /files/{id})
	RetrieveFile(w http.ResponseWriter, r *http.Request, id string)
	// Test endpoint
	// (GET /ping)
	Ping(w http.ResponseWriter, r *http.Request)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Retrieves account related information
// (GET /account.json)
func (_ Unimplemented) Account(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Creates a temporary authentication token
// (POST /auth/tokens)
func (_ Unimplemented) CreateToken(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Deletes a previously created temporary authentication token
// (DELETE /auth/tokens/{id})
func (_ Unimplemented) DeleteToken(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Retrieves a previously created temporary authentication token
// (GET /auth/tokens/{id})
func (_ Unimplemented) RetrieveToken(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Submits content for processing
// (POST /files)
func (_ Unimplemented) ProcessFile(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Submits content for processing asynchronously
// (POST /files/async)
func (_ Unimplemented) ProcessFileAsync(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Submits a URL for processing asynchronously
// (POST /files/fetch)
func (_ Unimplemented) ProcessFileFetch(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Retrieves a previously created processing result
// (GET /files/{id})
func (_ Unimplemented) RetrieveFile(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Test endpoint
// (GET /ping)
func (_ Unimplemented) Ping(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// Account operation middleware
func (siw *ServerInterfaceWrapper) Account(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Account(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// CreateToken operation middleware
func (siw *ServerInterfaceWrapper) CreateToken(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateToken(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteToken operation middleware
func (siw *ServerInterfaceWrapper) DeleteToken(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteToken(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// RetrieveToken operation middleware
func (siw *ServerInterfaceWrapper) RetrieveToken(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RetrieveToken(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ProcessFile operation middleware
func (siw *ServerInterfaceWrapper) ProcessFile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ProcessFile(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ProcessFileAsync operation middleware
func (siw *ServerInterfaceWrapper) ProcessFileAsync(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ProcessFileAsync(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ProcessFileFetch operation middleware
func (siw *ServerInterfaceWrapper) ProcessFileFetch(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ProcessFileFetch(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// RetrieveFile operation middleware
func (siw *ServerInterfaceWrapper) RetrieveFile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RetrieveFile(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// Ping operation middleware
func (siw *ServerInterfaceWrapper) Ping(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Ping(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/account.json", wrapper.Account)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/tokens", wrapper.CreateToken)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/tokens/{id}", wrapper.DeleteToken)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/tokens/{id}", wrapper.RetrieveToken)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/files", wrapper.ProcessFile)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/files/async", wrapper.ProcessFileAsync)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/files/fetch", wrapper.ProcessFileFetch)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/files/{id}", wrapper.RetrieveFile)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/ping", wrapper.Ping)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
