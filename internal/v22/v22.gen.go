// Package v22 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package v22

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	TokenScopes = "token.Scopes"
)

// AccountInfo defines model for AccountInfo.
type AccountInfo struct {
	Balance          *float32           `json:"balance,omitempty"`
	BillingEmail     *string            `json:"billing_email,omitempty"`
	CreationDate     *string            `json:"creation_date,omitempty"`
	Keys             *map[string]ApiKey `json:"keys,omitempty"`
	ModificationDate *string            `json:"modification_date,omitempty"`
	Name             *string            `json:"name,omitempty"`
	StartingBalance  *float32           `json:"starting_balance,omitempty"`
	Subscription     *string            `json:"subscription,omitempty"`
	Users            *map[string]User   `json:"users,omitempty"`
}

// ApiKey defines model for ApiKey.
type ApiKey struct {
	Active                     *bool     `json:"active,omitempty"`
	CreationDate               *string   `json:"creation_date,omitempty"`
	DetectionCategoriesEnabled *[]string `json:"detection_categories_enabled,omitempty"`
	LastSeenDate               *string   `json:"last_seen_date,omitempty"`
	Tags                       *[]string `json:"tags,omitempty"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error    *string                    `json:"error"`
	Id       *string                    `json:"id"`
	Metadata *map[string]MetadataObject `json:"metadata,omitempty"`
}

// MetadataObject Arbitrary set of user-supplied key/value pairs
type MetadataObject map[string]string

// ProcessingPendingResponse Entity representation of a pending content analysis
type ProcessingPendingResponse struct {
	// Id This result unique identifier, should be used to retried the result of the analysis
	Id *string `json:"id,omitempty"`
}

// ProcessingResponse Entity representation the result of a file analysis. Please note that this entity is only returned for
// synchronous requests. For asynchronous requests please refer to the [Files](#tag/Files) resource.
type ProcessingResponse struct {
	// Checksum The SHA1 digest of the content processed
	Checksum *string `json:"checksum,omitempty"`

	// ContentLength The length in bytes of the content processed
	ContentLength *float32 `json:"content_length,omitempty"`

	// ContentType The media type of the content processed
	ContentType *string `json:"content_type,omitempty"`

	// CreationDate ISO8601 time stamp of when the content was processed
	CreationDate *string `json:"creation_date,omitempty"`

	// Findings These are the labels/findings identified by our detection engines using a dot notation for hierarchies, for
	// example: content.malicious.foo or content.malicious.bar. Please note that the actual findings will vary based
	// on the content type and the detection engines enabled for your API key.
	// As of this API version common content hierarchies include:
	//
	// * content.malicious.{{name}} - malicious content like malware and spam
	// * content.images.nsfw.{{name}} - unsafe image
	// * content.{{ISO_3166-1_alpha-2 country code}}.language.nsfw - unsafe language
	//
	// A empty findings array means that no findings were identified for the content processed and it should be considered *safe*.
	Findings *[]string `json:"findings,omitempty"`

	// Id This result unique identifier, should be used to retried the result of the analysis
	Id       *string            `json:"id,omitempty"`
	Metadata *map[string]string `json:"metadata,omitempty"`
}

// User defines model for User.
type User struct {
	CreationDate *string `json:"creation_date,omitempty"`
	LastLogin    *string `json:"last_login,omitempty"`
}

// N401 defines model for 401.
type N401 = ErrorResponse

// CreateTokenFormdataBody defines parameters for CreateToken.
type CreateTokenFormdataBody struct {
	// Timeout Number of seconds this token should be valid for
	Timeout *int64 `form:"timeout,omitempty" json:"timeout,omitempty"`
}

// ProcessFileMultipartBody defines parameters for ProcessFile.
type ProcessFileMultipartBody struct {
	// File File to analyze
	File openapi_types.File `json:"file"`

	// Location URL to fetch and analyze
	Location string             `json:"location"`
	Metadata *map[string]string `json:"metadata,omitempty"`
}

// ProcessFileAsyncMultipartBody defines parameters for ProcessFileAsync.
type ProcessFileAsyncMultipartBody struct {
	// Callback Callback URL to notify once processing is completed
	Callback *string `json:"callback,omitempty"`

	// File File to analyze
	File *openapi_types.File `json:"file,omitempty"`

	// Metadata Arbitrary set of user-supplied key/value pairs
	Metadata *MetadataObject `json:"metadata,omitempty"`
}

// ProcessFileFetchFormdataBody defines parameters for ProcessFileFetch.
type ProcessFileFetchFormdataBody struct {
	// Callback Callback URL to notify once processing is completed
	Callback *string `form:"callback,omitempty" json:"callback,omitempty"`

	// Location URL to fetch and analyze
	Location             *string           `form:"location,omitempty" json:"location,omitempty"`
	AdditionalProperties map[string]string `json:"-"`
}

// CreateTokenFormdataRequestBody defines body for CreateToken for application/x-www-form-urlencoded ContentType.
type CreateTokenFormdataRequestBody CreateTokenFormdataBody

// ProcessFileMultipartRequestBody defines body for ProcessFile for multipart/form-data ContentType.
type ProcessFileMultipartRequestBody ProcessFileMultipartBody

// ProcessFileAsyncMultipartRequestBody defines body for ProcessFileAsync for multipart/form-data ContentType.
type ProcessFileAsyncMultipartRequestBody ProcessFileAsyncMultipartBody

// ProcessFileFetchFormdataRequestBody defines body for ProcessFileFetch for application/x-www-form-urlencoded ContentType.
type ProcessFileFetchFormdataRequestBody ProcessFileFetchFormdataBody

// Getter for additional properties for ProcessFileFetchFormdataBody. Returns the specified
// element and whether it was found
func (a ProcessFileFetchFormdataBody) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ProcessFileFetchFormdataBody
func (a *ProcessFileFetchFormdataBody) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ProcessFileFetchFormdataBody to handle AdditionalProperties
func (a *ProcessFileFetchFormdataBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["callback"]; found {
		err = json.Unmarshal(raw, &a.Callback)
		if err != nil {
			return fmt.Errorf("error reading 'callback': %w", err)
		}
		delete(object, "callback")
	}

	if raw, found := object["location"]; found {
		err = json.Unmarshal(raw, &a.Location)
		if err != nil {
			return fmt.Errorf("error reading 'location': %w", err)
		}
		delete(object, "location")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ProcessFileFetchFormdataBody to handle AdditionalProperties
func (a ProcessFileFetchFormdataBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Callback != nil {
		object["callback"], err = json.Marshal(a.Callback)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'callback': %w", err)
		}
	}

	if a.Location != nil {
		object["location"], err = json.Marshal(a.Location)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'location': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// Account request
	Account(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTokenWithBody request with any body
	CreateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTokenWithFormdataBody(ctx context.Context, body CreateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteToken request
	DeleteToken(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetToken request
	GetToken(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProcessFileWithBody request with any body
	ProcessFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProcessFileAsyncWithBody request with any body
	ProcessFileAsyncWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProcessFileFetchWithBody request with any body
	ProcessFileFetchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProcessFileFetchWithFormdataBody(ctx context.Context, body ProcessFileFetchFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveFile request
	RetrieveFile(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Ping request
	Ping(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) Account(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTokenWithFormdataBody(ctx context.Context, body CreateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteToken(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTokenRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetToken(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTokenRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProcessFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessFileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProcessFileAsyncWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessFileAsyncRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProcessFileFetchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessFileFetchRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProcessFileFetchWithFormdataBody(ctx context.Context, body ProcessFileFetchFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessFileFetchRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveFile(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveFileRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Ping(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPingRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAccountRequest generates requests for Account
func NewAccountRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/account.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTokenRequestWithFormdataBody calls the generic CreateToken builder with application/x-www-form-urlencoded body
func NewCreateTokenRequestWithFormdataBody(server string, body CreateTokenFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewCreateTokenRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewCreateTokenRequestWithBody generates requests for CreateToken with any type of body
func NewCreateTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTokenRequest generates requests for DeleteToken
func NewDeleteTokenRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/tokens/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTokenRequest generates requests for GetToken
func NewGetTokenRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/tokens/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProcessFileRequestWithBody generates requests for ProcessFile with any type of body
func NewProcessFileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProcessFileAsyncRequestWithBody generates requests for ProcessFileAsync with any type of body
func NewProcessFileAsyncRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/async")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProcessFileFetchRequestWithFormdataBody calls the generic ProcessFileFetch builder with application/x-www-form-urlencoded body
func NewProcessFileFetchRequestWithFormdataBody(server string, body ProcessFileFetchFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewProcessFileFetchRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewProcessFileFetchRequestWithBody generates requests for ProcessFileFetch with any type of body
func NewProcessFileFetchRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/fetch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRetrieveFileRequest generates requests for RetrieveFile
func NewRetrieveFileRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPingRequest generates requests for Ping
func NewPingRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ping")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AccountWithResponse request
	AccountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AccountResponse, error)

	// CreateTokenWithBodyWithResponse request with any body
	CreateTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	CreateTokenWithFormdataBodyWithResponse(ctx context.Context, body CreateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	// DeleteTokenWithResponse request
	DeleteTokenWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteTokenResponse, error)

	// GetTokenWithResponse request
	GetTokenWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetTokenResponse, error)

	// ProcessFileWithBodyWithResponse request with any body
	ProcessFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessFileResponse, error)

	// ProcessFileAsyncWithBodyWithResponse request with any body
	ProcessFileAsyncWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessFileAsyncResponse, error)

	// ProcessFileFetchWithBodyWithResponse request with any body
	ProcessFileFetchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessFileFetchResponse, error)

	ProcessFileFetchWithFormdataBodyWithResponse(ctx context.Context, body ProcessFileFetchFormdataRequestBody, reqEditors ...RequestEditorFn) (*ProcessFileFetchResponse, error)

	// RetrieveFileWithResponse request
	RetrieveFileWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RetrieveFileResponse, error)

	// PingWithResponse request
	PingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PingResponse, error)
}

type AccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountInfo
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r AccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CreationDate   *string `json:"creation_date,omitempty"`
		ExpirationDate *string `json:"expiration_date,omitempty"`
		Id             *string `json:"id,omitempty"`
	}
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r DeleteTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CreationDate   *string `json:"creation_date,omitempty"`
		ExpirationDate *string `json:"expiration_date,omitempty"`
		Id             *string `json:"id,omitempty"`
	}
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r GetTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProcessFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ProcessingResponse
	JSON400      *ErrorResponse
	JSON401      *N401
	JSON403      *ErrorResponse
	JSON413      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ProcessFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProcessFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProcessFileAsyncResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *ProcessingPendingResponse
	JSON400      *ErrorResponse
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r ProcessFileAsyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProcessFileAsyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProcessFileFetchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *ProcessingPendingResponse
	JSON400      *ErrorResponse
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r ProcessFileFetchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProcessFileFetchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProcessingResponse
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r RetrieveFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Key Returns the public key used
		Key     *string `json:"key,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r PingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AccountWithResponse request returning *AccountResponse
func (c *ClientWithResponses) AccountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AccountResponse, error) {
	rsp, err := c.Account(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountResponse(rsp)
}

// CreateTokenWithBodyWithResponse request with arbitrary body returning *CreateTokenResponse
func (c *ClientWithResponses) CreateTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateTokenWithFormdataBodyWithResponse(ctx context.Context, body CreateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateTokenWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

// DeleteTokenWithResponse request returning *DeleteTokenResponse
func (c *ClientWithResponses) DeleteTokenWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteTokenResponse, error) {
	rsp, err := c.DeleteToken(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTokenResponse(rsp)
}

// GetTokenWithResponse request returning *GetTokenResponse
func (c *ClientWithResponses) GetTokenWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetTokenResponse, error) {
	rsp, err := c.GetToken(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTokenResponse(rsp)
}

// ProcessFileWithBodyWithResponse request with arbitrary body returning *ProcessFileResponse
func (c *ClientWithResponses) ProcessFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessFileResponse, error) {
	rsp, err := c.ProcessFileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessFileResponse(rsp)
}

// ProcessFileAsyncWithBodyWithResponse request with arbitrary body returning *ProcessFileAsyncResponse
func (c *ClientWithResponses) ProcessFileAsyncWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessFileAsyncResponse, error) {
	rsp, err := c.ProcessFileAsyncWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessFileAsyncResponse(rsp)
}

// ProcessFileFetchWithBodyWithResponse request with arbitrary body returning *ProcessFileFetchResponse
func (c *ClientWithResponses) ProcessFileFetchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessFileFetchResponse, error) {
	rsp, err := c.ProcessFileFetchWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessFileFetchResponse(rsp)
}

func (c *ClientWithResponses) ProcessFileFetchWithFormdataBodyWithResponse(ctx context.Context, body ProcessFileFetchFormdataRequestBody, reqEditors ...RequestEditorFn) (*ProcessFileFetchResponse, error) {
	rsp, err := c.ProcessFileFetchWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessFileFetchResponse(rsp)
}

// RetrieveFileWithResponse request returning *RetrieveFileResponse
func (c *ClientWithResponses) RetrieveFileWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RetrieveFileResponse, error) {
	rsp, err := c.RetrieveFile(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveFileResponse(rsp)
}

// PingWithResponse request returning *PingResponse
func (c *ClientWithResponses) PingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PingResponse, error) {
	rsp, err := c.Ping(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePingResponse(rsp)
}

// ParseAccountResponse parses an HTTP response from a AccountWithResponse call
func ParseAccountResponse(rsp *http.Response) (*AccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateTokenResponse parses an HTTP response from a CreateTokenWithResponse call
func ParseCreateTokenResponse(rsp *http.Response) (*CreateTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CreationDate   *string `json:"creation_date,omitempty"`
			ExpirationDate *string `json:"expiration_date,omitempty"`
			Id             *string `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteTokenResponse parses an HTTP response from a DeleteTokenWithResponse call
func ParseDeleteTokenResponse(rsp *http.Response) (*DeleteTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetTokenResponse parses an HTTP response from a GetTokenWithResponse call
func ParseGetTokenResponse(rsp *http.Response) (*GetTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CreationDate   *string `json:"creation_date,omitempty"`
			ExpirationDate *string `json:"expiration_date,omitempty"`
			Id             *string `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseProcessFileResponse parses an HTTP response from a ProcessFileWithResponse call
func ParseProcessFileResponse(rsp *http.Response) (*ProcessFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProcessFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ProcessingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	}

	return response, nil
}

// ParseProcessFileAsyncResponse parses an HTTP response from a ProcessFileAsyncWithResponse call
func ParseProcessFileAsyncResponse(rsp *http.Response) (*ProcessFileAsyncResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProcessFileAsyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ProcessingPendingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseProcessFileFetchResponse parses an HTTP response from a ProcessFileFetchWithResponse call
func ParseProcessFileFetchResponse(rsp *http.Response) (*ProcessFileFetchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProcessFileFetchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ProcessingPendingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRetrieveFileResponse parses an HTTP response from a RetrieveFileWithResponse call
func ParseRetrieveFileResponse(rsp *http.Response) (*RetrieveFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParsePingResponse parses an HTTP response from a PingWithResponse call
func ParsePingResponse(rsp *http.Response) (*PingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Key Returns the public key used
			Key     *string `json:"key,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Retrieves account related information
	// (GET /account.json)
	Account(w http.ResponseWriter, r *http.Request)
	// Creates a temporary authentication token
	// (POST /auth/tokens)
	CreateToken(w http.ResponseWriter, r *http.Request)
	// Deletes a previously created temporary authentication token
	// (DELETE /auth/tokens/{id})
	DeleteToken(w http.ResponseWriter, r *http.Request, id string)
	// Retrieves a previously created temporary authentication token
	// (GET /auth/tokens/{id})
	GetToken(w http.ResponseWriter, r *http.Request, id string)
	// Submits content for processing
	// (POST /files)
	ProcessFile(w http.ResponseWriter, r *http.Request)
	// Submits content for processing asynchronously
	// (POST /files/async)
	ProcessFileAsync(w http.ResponseWriter, r *http.Request)
	// Submits a URL for processing asynchronously
	// (POST /files/fetch)
	ProcessFileFetch(w http.ResponseWriter, r *http.Request)
	// Retrieves a previously created processing result
	// (GET /files/{id})
	RetrieveFile(w http.ResponseWriter, r *http.Request, id string)
	// Test endpoint
	// (GET /ping)
	Ping(w http.ResponseWriter, r *http.Request)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Retrieves account related information
// (GET /account.json)
func (_ Unimplemented) Account(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Creates a temporary authentication token
// (POST /auth/tokens)
func (_ Unimplemented) CreateToken(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Deletes a previously created temporary authentication token
// (DELETE /auth/tokens/{id})
func (_ Unimplemented) DeleteToken(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Retrieves a previously created temporary authentication token
// (GET /auth/tokens/{id})
func (_ Unimplemented) GetToken(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Submits content for processing
// (POST /files)
func (_ Unimplemented) ProcessFile(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Submits content for processing asynchronously
// (POST /files/async)
func (_ Unimplemented) ProcessFileAsync(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Submits a URL for processing asynchronously
// (POST /files/fetch)
func (_ Unimplemented) ProcessFileFetch(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Retrieves a previously created processing result
// (GET /files/{id})
func (_ Unimplemented) RetrieveFile(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Test endpoint
// (GET /ping)
func (_ Unimplemented) Ping(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// Account operation middleware
func (siw *ServerInterfaceWrapper) Account(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Account(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// CreateToken operation middleware
func (siw *ServerInterfaceWrapper) CreateToken(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateToken(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteToken operation middleware
func (siw *ServerInterfaceWrapper) DeleteToken(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteToken(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetToken operation middleware
func (siw *ServerInterfaceWrapper) GetToken(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetToken(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ProcessFile operation middleware
func (siw *ServerInterfaceWrapper) ProcessFile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ProcessFile(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ProcessFileAsync operation middleware
func (siw *ServerInterfaceWrapper) ProcessFileAsync(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ProcessFileAsync(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ProcessFileFetch operation middleware
func (siw *ServerInterfaceWrapper) ProcessFileFetch(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ProcessFileFetch(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// RetrieveFile operation middleware
func (siw *ServerInterfaceWrapper) RetrieveFile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RetrieveFile(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// Ping operation middleware
func (siw *ServerInterfaceWrapper) Ping(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Ping(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/account.json", wrapper.Account)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/tokens", wrapper.CreateToken)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/tokens/{id}", wrapper.DeleteToken)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/tokens/{id}", wrapper.GetToken)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/files", wrapper.ProcessFile)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/files/async", wrapper.ProcessFileAsync)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/files/fetch", wrapper.ProcessFileFetch)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/files/{id}", wrapper.RetrieveFile)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/ping", wrapper.Ping)
	})

	return r
}

type N401ResponseHeaders struct {
	XScaniiHostId    string
	XScaniiRequestId string
}
type N401JSONResponse struct {
	Body ErrorResponse

	Headers N401ResponseHeaders
}

type AccountRequestObject struct {
}

type AccountResponseObject interface {
	VisitAccountResponse(w http.ResponseWriter) error
}

type Account200ResponseHeaders struct {
	XScaniiHostId    string
	XScaniiRequestId string
}

type Account200JSONResponse struct {
	Body    AccountInfo
	Headers Account200ResponseHeaders
}

func (response Account200JSONResponse) VisitAccountResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type Account401JSONResponse struct{ N401JSONResponse }

func (response Account401JSONResponse) VisitAccountResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateTokenRequestObject struct {
	Body *CreateTokenFormdataRequestBody
}

type CreateTokenResponseObject interface {
	VisitCreateTokenResponse(w http.ResponseWriter) error
}

type CreateToken200ResponseHeaders struct {
	XScaniiHostId    string
	XScaniiRequestId string
}

type CreateToken200JSONResponse struct {
	Body struct {
		CreationDate   *string `json:"creation_date,omitempty"`
		ExpirationDate *string `json:"expiration_date,omitempty"`
		Id             *string `json:"id,omitempty"`
	}
	Headers CreateToken200ResponseHeaders
}

func (response CreateToken200JSONResponse) VisitCreateTokenResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateToken401JSONResponse struct{ N401JSONResponse }

func (response CreateToken401JSONResponse) VisitCreateTokenResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteTokenRequestObject struct {
	Id string `json:"id"`
}

type DeleteTokenResponseObject interface {
	VisitDeleteTokenResponse(w http.ResponseWriter) error
}

type DeleteToken204ResponseHeaders struct {
	XScaniiHostId    string
	XScaniiRequestId string
}

type DeleteToken204Response struct {
	Headers DeleteToken204ResponseHeaders
}

func (response DeleteToken204Response) VisitDeleteTokenResponse(w http.ResponseWriter) error {
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(204)
	return nil
}

type DeleteToken401JSONResponse struct{ N401JSONResponse }

func (response DeleteToken401JSONResponse) VisitDeleteTokenResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetTokenRequestObject struct {
	Id string `json:"id"`
}

type GetTokenResponseObject interface {
	VisitGetTokenResponse(w http.ResponseWriter) error
}

type GetToken200ResponseHeaders struct {
	XScaniiHostId    string
	XScaniiRequestId string
}

type GetToken200JSONResponse struct {
	Body struct {
		CreationDate   *string `json:"creation_date,omitempty"`
		ExpirationDate *string `json:"expiration_date,omitempty"`
		Id             *string `json:"id,omitempty"`
	}
	Headers GetToken200ResponseHeaders
}

func (response GetToken200JSONResponse) VisitGetTokenResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetToken401JSONResponse struct{ N401JSONResponse }

func (response GetToken401JSONResponse) VisitGetTokenResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

type ProcessFileRequestObject struct {
	Body *multipart.Reader
}

type ProcessFileResponseObject interface {
	VisitProcessFileResponse(w http.ResponseWriter) error
}

type ProcessFile201ResponseHeaders struct {
	Location         string
	XScaniiHostId    string
	XScaniiRequestId string
}

type ProcessFile201JSONResponse struct {
	Body    ProcessingResponse
	Headers ProcessFile201ResponseHeaders
}

func (response ProcessFile201JSONResponse) VisitProcessFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response.Body)
}

type ProcessFile400ResponseHeaders struct {
	XScaniiHostId    string
	XScaniiRequestId string
}

type ProcessFile400JSONResponse struct {
	Body    ErrorResponse
	Headers ProcessFile400ResponseHeaders
}

func (response ProcessFile400JSONResponse) VisitProcessFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.Body)
}

type ProcessFile401JSONResponse struct{ N401JSONResponse }

func (response ProcessFile401JSONResponse) VisitProcessFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

type ProcessFile403ResponseHeaders struct {
	XScaniiHostId    string
	XScaniiRequestId string
}

type ProcessFile403JSONResponse struct {
	Body    ErrorResponse
	Headers ProcessFile403ResponseHeaders
}

func (response ProcessFile403JSONResponse) VisitProcessFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response.Body)
}

type ProcessFile413ResponseHeaders struct {
	XScaniiHostId    string
	XScaniiRequestId string
}

type ProcessFile413JSONResponse struct {
	Body    ErrorResponse
	Headers ProcessFile413ResponseHeaders
}

func (response ProcessFile413JSONResponse) VisitProcessFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(413)

	return json.NewEncoder(w).Encode(response.Body)
}

type ProcessFileAsyncRequestObject struct {
	Body *multipart.Reader
}

type ProcessFileAsyncResponseObject interface {
	VisitProcessFileAsyncResponse(w http.ResponseWriter) error
}

type ProcessFileAsync202ResponseHeaders struct {
	Location         string
	XScaniiHostId    string
	XScaniiRequestId string
}

type ProcessFileAsync202JSONResponse struct {
	Body    ProcessingPendingResponse
	Headers ProcessFileAsync202ResponseHeaders
}

func (response ProcessFileAsync202JSONResponse) VisitProcessFileAsyncResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(202)

	return json.NewEncoder(w).Encode(response.Body)
}

type ProcessFileAsync400ResponseHeaders struct {
	XScaniiHostId    string
	XScaniiRequestId string
}

type ProcessFileAsync400JSONResponse struct {
	Body    ErrorResponse
	Headers ProcessFileAsync400ResponseHeaders
}

func (response ProcessFileAsync400JSONResponse) VisitProcessFileAsyncResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.Body)
}

type ProcessFileAsync401JSONResponse struct{ N401JSONResponse }

func (response ProcessFileAsync401JSONResponse) VisitProcessFileAsyncResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

type ProcessFileFetchRequestObject struct {
	Body *ProcessFileFetchFormdataRequestBody
}

type ProcessFileFetchResponseObject interface {
	VisitProcessFileFetchResponse(w http.ResponseWriter) error
}

type ProcessFileFetch202ResponseHeaders struct {
	Location         string
	XScaniiHostId    string
	XScaniiRequestId string
}

type ProcessFileFetch202JSONResponse struct {
	Body    ProcessingPendingResponse
	Headers ProcessFileFetch202ResponseHeaders
}

func (response ProcessFileFetch202JSONResponse) VisitProcessFileFetchResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(202)

	return json.NewEncoder(w).Encode(response.Body)
}

type ProcessFileFetch400ResponseHeaders struct {
	XScaniiHostId    string
	XScaniiRequestId string
}

type ProcessFileFetch400JSONResponse struct {
	Body    ErrorResponse
	Headers ProcessFileFetch400ResponseHeaders
}

func (response ProcessFileFetch400JSONResponse) VisitProcessFileFetchResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.Body)
}

type ProcessFileFetch401JSONResponse struct{ N401JSONResponse }

func (response ProcessFileFetch401JSONResponse) VisitProcessFileFetchResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

type RetrieveFileRequestObject struct {
	Id string `json:"id"`
}

type RetrieveFileResponseObject interface {
	VisitRetrieveFileResponse(w http.ResponseWriter) error
}

type RetrieveFile200ResponseHeaders struct {
	XScaniiHostId    string
	XScaniiRequestId string
}

type RetrieveFile200JSONResponse struct {
	Body    ProcessingResponse
	Headers RetrieveFile200ResponseHeaders
}

func (response RetrieveFile200JSONResponse) VisitRetrieveFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type RetrieveFile401JSONResponse struct{ N401JSONResponse }

func (response RetrieveFile401JSONResponse) VisitRetrieveFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

type PingRequestObject struct {
}

type PingResponseObject interface {
	VisitPingResponse(w http.ResponseWriter) error
}

type Ping200ResponseHeaders struct {
	XScaniiHostId    string
	XScaniiRequestId string
}

type Ping200JSONResponse struct {
	Body struct {
		// Key Returns the public key used
		Key     *string `json:"key,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	Headers Ping200ResponseHeaders
}

func (response Ping200JSONResponse) VisitPingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type Ping401JSONResponse struct{ N401JSONResponse }

func (response Ping401JSONResponse) VisitPingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Retrieves account related information
	// (GET /account.json)
	Account(ctx context.Context, request AccountRequestObject) (AccountResponseObject, error)
	// Creates a temporary authentication token
	// (POST /auth/tokens)
	CreateToken(ctx context.Context, request CreateTokenRequestObject) (CreateTokenResponseObject, error)
	// Deletes a previously created temporary authentication token
	// (DELETE /auth/tokens/{id})
	DeleteToken(ctx context.Context, request DeleteTokenRequestObject) (DeleteTokenResponseObject, error)
	// Retrieves a previously created temporary authentication token
	// (GET /auth/tokens/{id})
	GetToken(ctx context.Context, request GetTokenRequestObject) (GetTokenResponseObject, error)
	// Submits content for processing
	// (POST /files)
	ProcessFile(ctx context.Context, request ProcessFileRequestObject) (ProcessFileResponseObject, error)
	// Submits content for processing asynchronously
	// (POST /files/async)
	ProcessFileAsync(ctx context.Context, request ProcessFileAsyncRequestObject) (ProcessFileAsyncResponseObject, error)
	// Submits a URL for processing asynchronously
	// (POST /files/fetch)
	ProcessFileFetch(ctx context.Context, request ProcessFileFetchRequestObject) (ProcessFileFetchResponseObject, error)
	// Retrieves a previously created processing result
	// (GET /files/{id})
	RetrieveFile(ctx context.Context, request RetrieveFileRequestObject) (RetrieveFileResponseObject, error)
	// Test endpoint
	// (GET /ping)
	Ping(ctx context.Context, request PingRequestObject) (PingResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// Account operation middleware
func (sh *strictHandler) Account(w http.ResponseWriter, r *http.Request) {
	var request AccountRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.Account(ctx, request.(AccountRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "Account")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AccountResponseObject); ok {
		if err := validResponse.VisitAccountResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateToken operation middleware
func (sh *strictHandler) CreateToken(w http.ResponseWriter, r *http.Request) {
	var request CreateTokenRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body CreateTokenFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreateToken(ctx, request.(CreateTokenRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateToken")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreateTokenResponseObject); ok {
		if err := validResponse.VisitCreateTokenResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteToken operation middleware
func (sh *strictHandler) DeleteToken(w http.ResponseWriter, r *http.Request, id string) {
	var request DeleteTokenRequestObject

	request.Id = id

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteToken(ctx, request.(DeleteTokenRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteToken")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteTokenResponseObject); ok {
		if err := validResponse.VisitDeleteTokenResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetToken operation middleware
func (sh *strictHandler) GetToken(w http.ResponseWriter, r *http.Request, id string) {
	var request GetTokenRequestObject

	request.Id = id

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetToken(ctx, request.(GetTokenRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetToken")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetTokenResponseObject); ok {
		if err := validResponse.VisitGetTokenResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ProcessFile operation middleware
func (sh *strictHandler) ProcessFile(w http.ResponseWriter, r *http.Request) {
	var request ProcessFileRequestObject

	if reader, err := r.MultipartReader(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode multipart body: %w", err))
		return
	} else {
		request.Body = reader
	}

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ProcessFile(ctx, request.(ProcessFileRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ProcessFile")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ProcessFileResponseObject); ok {
		if err := validResponse.VisitProcessFileResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ProcessFileAsync operation middleware
func (sh *strictHandler) ProcessFileAsync(w http.ResponseWriter, r *http.Request) {
	var request ProcessFileAsyncRequestObject

	if reader, err := r.MultipartReader(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode multipart body: %w", err))
		return
	} else {
		request.Body = reader
	}

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ProcessFileAsync(ctx, request.(ProcessFileAsyncRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ProcessFileAsync")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ProcessFileAsyncResponseObject); ok {
		if err := validResponse.VisitProcessFileAsyncResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ProcessFileFetch operation middleware
func (sh *strictHandler) ProcessFileFetch(w http.ResponseWriter, r *http.Request) {
	var request ProcessFileFetchRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body ProcessFileFetchFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ProcessFileFetch(ctx, request.(ProcessFileFetchRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ProcessFileFetch")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ProcessFileFetchResponseObject); ok {
		if err := validResponse.VisitProcessFileFetchResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// RetrieveFile operation middleware
func (sh *strictHandler) RetrieveFile(w http.ResponseWriter, r *http.Request, id string) {
	var request RetrieveFileRequestObject

	request.Id = id

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.RetrieveFile(ctx, request.(RetrieveFileRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RetrieveFile")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(RetrieveFileResponseObject); ok {
		if err := validResponse.VisitRetrieveFileResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Ping operation middleware
func (sh *strictHandler) Ping(w http.ResponseWriter, r *http.Request) {
	var request PingRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.Ping(ctx, request.(PingRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "Ping")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PingResponseObject); ok {
		if err := validResponse.VisitPingResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
