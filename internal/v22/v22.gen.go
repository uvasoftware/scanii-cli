// Package v22 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package v22

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	TokenScopes = "token.Scopes"
)

// AccountInfo defines model for AccountInfo.
type AccountInfo struct {
	Balance          *float32           `json:"balance,omitempty"`
	BillingEmail     *string            `json:"billing_email,omitempty"`
	CreationDate     *string            `json:"creation_date,omitempty"`
	Keys             *map[string]ApiKey `json:"keys,omitempty"`
	ModificationDate *string            `json:"modification_date,omitempty"`
	Name             *string            `json:"name,omitempty"`
	StartingBalance  *float32           `json:"starting_balance,omitempty"`
	Subscription     *string            `json:"subscription,omitempty"`
	Users            *map[string]User   `json:"users,omitempty"`
}

// ApiKey defines model for ApiKey.
type ApiKey struct {
	Active                     *bool     `json:"active,omitempty"`
	CreationDate               *string   `json:"creation_date,omitempty"`
	DetectionCategoriesEnabled *[]string `json:"detection_categories_enabled,omitempty"`
	LastSeenDate               *string   `json:"last_seen_date,omitempty"`
	Tags                       *[]string `json:"tags,omitempty"`
}

// AuthToken defines model for AuthToken.
type AuthToken struct {
	CreationDate   *string `json:"creation_date,omitempty"`
	ExpirationDate *string `json:"expiration_date,omitempty"`
	Id             *string `json:"id,omitempty"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error    *string            `json:"error"`
	Id       *string            `json:"id"`
	Metadata *map[string]string `json:"metadata,omitempty"`
}

// ProcessingPendingResponse Entity representation of a pending content analysis
type ProcessingPendingResponse struct {
	// Id This result unique identifier, should be used to retried the result of the analysis
	Id *string `json:"id,omitempty"`
}

// ProcessingResponse Entity representation the result of a file analysis. Please note that this entity is only returned for
// synchronous requests. For asynchronous requests please refer to the [Files](#tag/Files) resource.
type ProcessingResponse struct {
	// Checksum The SHA1 digest of the content processed
	Checksum *string `json:"checksum"`

	// ContentLength The length in bytes of the content processed
	ContentLength *float32 `json:"content_length"`

	// ContentType The media type of the content processed
	ContentType *string `json:"content_type"`

	// CreationDate ISO8601 time stamp of when the content was processed
	CreationDate *string `json:"creation_date"`

	// Error If an error occurred during processing this field will contain the error message. Please note that this field is only
	// present if an error occurred during processing.
	Error *string `json:"error"`

	// Findings These are the labels/findings identified by our detection engines using a dot notation for hierarchies, for
	// example: content.malicious.foo or content.malicious.bar. Please note that the actual findings will vary based
	// on the content type and the detection engines enabled for your API key.
	// As of this API version common content hierarchies include:
	//
	// * content.malicious.{{name}} - malicious content like malware and spam
	// * content.images.nsfw.{{name}} - unsafe image
	// * content.{{ISO_3166-1_alpha-2 country code}}.language.nsfw - unsafe language
	//
	// A empty findings array means that no findings were identified for the content processed and it should be considered *safe*.
	Findings *[]string `json:"findings"`

	// Id This result unique identifier, should be used to retried the result of the analysis
	Id       *string            `json:"id,omitempty"`
	Metadata *map[string]string `json:"metadata"`
}

// User defines model for User.
type User struct {
	CreationDate *string `json:"creation_date,omitempty"`
	LastLogin    *string `json:"last_login,omitempty"`
}

// N401 defines model for 401.
type N401 = ErrorResponse

// CreateTokenFormdataBody defines parameters for CreateToken.
type CreateTokenFormdataBody struct {
	// Timeout Number of seconds this token should be valid for
	Timeout *int64 `form:"timeout,omitempty" json:"timeout,omitempty"`
}

// ProcessFileMultipartBody defines parameters for ProcessFile.
type ProcessFileMultipartBody struct {
	// File File to analyze
	File openapi_types.File `json:"file"`

	// Location URL to fetch and analyze
	Location string             `json:"location"`
	Metadata *map[string]string `json:"metadata,omitempty"`
}

// ProcessFileAsyncMultipartBody defines parameters for ProcessFileAsync.
type ProcessFileAsyncMultipartBody struct {
	// Callback Callback URL to notify once processing is completed
	Callback *string `json:"callback,omitempty"`

	// File File to analyze
	File     *openapi_types.File `json:"file,omitempty"`
	Metadata *map[string]string  `json:"metadata,omitempty"`
}

// ProcessFileFetchFormdataBody defines parameters for ProcessFileFetch.
type ProcessFileFetchFormdataBody struct {
	// Callback Callback URL to notify once processing is completed
	Callback *string `form:"callback,omitempty" json:"callback,omitempty"`

	// Location URL to fetch and analyze
	Location             *string           `form:"location,omitempty" json:"location,omitempty"`
	AdditionalProperties map[string]string `json:"-"`
}

// CreateTokenFormdataRequestBody defines body for CreateToken for application/x-www-form-urlencoded ContentType.
type CreateTokenFormdataRequestBody CreateTokenFormdataBody

// ProcessFileMultipartRequestBody defines body for ProcessFile for multipart/form-data ContentType.
type ProcessFileMultipartRequestBody ProcessFileMultipartBody

// ProcessFileAsyncMultipartRequestBody defines body for ProcessFileAsync for multipart/form-data ContentType.
type ProcessFileAsyncMultipartRequestBody ProcessFileAsyncMultipartBody

// ProcessFileFetchFormdataRequestBody defines body for ProcessFileFetch for application/x-www-form-urlencoded ContentType.
type ProcessFileFetchFormdataRequestBody ProcessFileFetchFormdataBody

// Getter for additional properties for ProcessFileFetchFormdataBody. Returns the specified
// element and whether it was found
func (a ProcessFileFetchFormdataBody) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ProcessFileFetchFormdataBody
func (a *ProcessFileFetchFormdataBody) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ProcessFileFetchFormdataBody to handle AdditionalProperties
func (a *ProcessFileFetchFormdataBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["callback"]; found {
		err = json.Unmarshal(raw, &a.Callback)
		if err != nil {
			return fmt.Errorf("error reading 'callback': %w", err)
		}
		delete(object, "callback")
	}

	if raw, found := object["location"]; found {
		err = json.Unmarshal(raw, &a.Location)
		if err != nil {
			return fmt.Errorf("error reading 'location': %w", err)
		}
		delete(object, "location")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ProcessFileFetchFormdataBody to handle AdditionalProperties
func (a ProcessFileFetchFormdataBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Callback != nil {
		object["callback"], err = json.Marshal(a.Callback)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'callback': %w", err)
		}
	}

	if a.Location != nil {
		object["location"], err = json.Marshal(a.Location)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'location': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// Account request
	Account(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTokenWithBody request with any body
	CreateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTokenWithFormdataBody(ctx context.Context, body CreateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteToken request
	DeleteToken(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveToken request
	RetrieveToken(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProcessFileWithBody request with any body
	ProcessFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProcessFileAsyncWithBody request with any body
	ProcessFileAsyncWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProcessFileFetchWithBody request with any body
	ProcessFileFetchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProcessFileFetchWithFormdataBody(ctx context.Context, body ProcessFileFetchFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveFile request
	RetrieveFile(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Ping request
	Ping(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) Account(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTokenWithFormdataBody(ctx context.Context, body CreateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteToken(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTokenRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveToken(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveTokenRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProcessFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessFileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProcessFileAsyncWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessFileAsyncRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProcessFileFetchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessFileFetchRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProcessFileFetchWithFormdataBody(ctx context.Context, body ProcessFileFetchFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessFileFetchRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveFile(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveFileRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Ping(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPingRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAccountRequest generates requests for Account
func NewAccountRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/account.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTokenRequestWithFormdataBody calls the generic CreateToken builder with application/x-www-form-urlencoded body
func NewCreateTokenRequestWithFormdataBody(server string, body CreateTokenFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewCreateTokenRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewCreateTokenRequestWithBody generates requests for CreateToken with any type of body
func NewCreateTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTokenRequest generates requests for DeleteToken
func NewDeleteTokenRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/tokens/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveTokenRequest generates requests for RetrieveToken
func NewRetrieveTokenRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/tokens/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProcessFileRequestWithBody generates requests for ProcessFile with any type of body
func NewProcessFileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProcessFileAsyncRequestWithBody generates requests for ProcessFileAsync with any type of body
func NewProcessFileAsyncRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/async")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProcessFileFetchRequestWithFormdataBody calls the generic ProcessFileFetch builder with application/x-www-form-urlencoded body
func NewProcessFileFetchRequestWithFormdataBody(server string, body ProcessFileFetchFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewProcessFileFetchRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewProcessFileFetchRequestWithBody generates requests for ProcessFileFetch with any type of body
func NewProcessFileFetchRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/fetch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRetrieveFileRequest generates requests for RetrieveFile
func NewRetrieveFileRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPingRequest generates requests for Ping
func NewPingRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ping")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AccountWithResponse request
	AccountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AccountResponse, error)

	// CreateTokenWithBodyWithResponse request with any body
	CreateTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	CreateTokenWithFormdataBodyWithResponse(ctx context.Context, body CreateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	// DeleteTokenWithResponse request
	DeleteTokenWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteTokenResponse, error)

	// RetrieveTokenWithResponse request
	RetrieveTokenWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RetrieveTokenResponse, error)

	// ProcessFileWithBodyWithResponse request with any body
	ProcessFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessFileResponse, error)

	// ProcessFileAsyncWithBodyWithResponse request with any body
	ProcessFileAsyncWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessFileAsyncResponse, error)

	// ProcessFileFetchWithBodyWithResponse request with any body
	ProcessFileFetchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessFileFetchResponse, error)

	ProcessFileFetchWithFormdataBodyWithResponse(ctx context.Context, body ProcessFileFetchFormdataRequestBody, reqEditors ...RequestEditorFn) (*ProcessFileFetchResponse, error)

	// RetrieveFileWithResponse request
	RetrieveFileWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RetrieveFileResponse, error)

	// PingWithResponse request
	PingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PingResponse, error)
}

type AccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountInfo
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r AccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AuthToken
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r CreateTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r DeleteTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthToken
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r RetrieveTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProcessFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ProcessingResponse
	JSON400      *ErrorResponse
	JSON401      *N401
	JSON403      *ErrorResponse
	JSON413      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ProcessFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProcessFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProcessFileAsyncResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *ProcessingPendingResponse
	JSON400      *ErrorResponse
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r ProcessFileAsyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProcessFileAsyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProcessFileFetchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *ProcessingPendingResponse
	JSON400      *ErrorResponse
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r ProcessFileFetchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProcessFileFetchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProcessingResponse
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r RetrieveFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Key Returns the public key used
		Key     *string `json:"key,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r PingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AccountWithResponse request returning *AccountResponse
func (c *ClientWithResponses) AccountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AccountResponse, error) {
	rsp, err := c.Account(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountResponse(rsp)
}

// CreateTokenWithBodyWithResponse request with arbitrary body returning *CreateTokenResponse
func (c *ClientWithResponses) CreateTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateTokenWithFormdataBodyWithResponse(ctx context.Context, body CreateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateTokenWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

// DeleteTokenWithResponse request returning *DeleteTokenResponse
func (c *ClientWithResponses) DeleteTokenWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteTokenResponse, error) {
	rsp, err := c.DeleteToken(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTokenResponse(rsp)
}

// RetrieveTokenWithResponse request returning *RetrieveTokenResponse
func (c *ClientWithResponses) RetrieveTokenWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RetrieveTokenResponse, error) {
	rsp, err := c.RetrieveToken(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveTokenResponse(rsp)
}

// ProcessFileWithBodyWithResponse request with arbitrary body returning *ProcessFileResponse
func (c *ClientWithResponses) ProcessFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessFileResponse, error) {
	rsp, err := c.ProcessFileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessFileResponse(rsp)
}

// ProcessFileAsyncWithBodyWithResponse request with arbitrary body returning *ProcessFileAsyncResponse
func (c *ClientWithResponses) ProcessFileAsyncWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessFileAsyncResponse, error) {
	rsp, err := c.ProcessFileAsyncWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessFileAsyncResponse(rsp)
}

// ProcessFileFetchWithBodyWithResponse request with arbitrary body returning *ProcessFileFetchResponse
func (c *ClientWithResponses) ProcessFileFetchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessFileFetchResponse, error) {
	rsp, err := c.ProcessFileFetchWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessFileFetchResponse(rsp)
}

func (c *ClientWithResponses) ProcessFileFetchWithFormdataBodyWithResponse(ctx context.Context, body ProcessFileFetchFormdataRequestBody, reqEditors ...RequestEditorFn) (*ProcessFileFetchResponse, error) {
	rsp, err := c.ProcessFileFetchWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessFileFetchResponse(rsp)
}

// RetrieveFileWithResponse request returning *RetrieveFileResponse
func (c *ClientWithResponses) RetrieveFileWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RetrieveFileResponse, error) {
	rsp, err := c.RetrieveFile(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveFileResponse(rsp)
}

// PingWithResponse request returning *PingResponse
func (c *ClientWithResponses) PingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PingResponse, error) {
	rsp, err := c.Ping(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePingResponse(rsp)
}

// ParseAccountResponse parses an HTTP response from a AccountWithResponse call
func ParseAccountResponse(rsp *http.Response) (*AccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateTokenResponse parses an HTTP response from a CreateTokenWithResponse call
func ParseCreateTokenResponse(rsp *http.Response) (*CreateTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AuthToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteTokenResponse parses an HTTP response from a DeleteTokenWithResponse call
func ParseDeleteTokenResponse(rsp *http.Response) (*DeleteTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRetrieveTokenResponse parses an HTTP response from a RetrieveTokenWithResponse call
func ParseRetrieveTokenResponse(rsp *http.Response) (*RetrieveTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseProcessFileResponse parses an HTTP response from a ProcessFileWithResponse call
func ParseProcessFileResponse(rsp *http.Response) (*ProcessFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProcessFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ProcessingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	}

	return response, nil
}

// ParseProcessFileAsyncResponse parses an HTTP response from a ProcessFileAsyncWithResponse call
func ParseProcessFileAsyncResponse(rsp *http.Response) (*ProcessFileAsyncResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProcessFileAsyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ProcessingPendingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseProcessFileFetchResponse parses an HTTP response from a ProcessFileFetchWithResponse call
func ParseProcessFileFetchResponse(rsp *http.Response) (*ProcessFileFetchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProcessFileFetchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ProcessingPendingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRetrieveFileResponse parses an HTTP response from a RetrieveFileWithResponse call
func ParseRetrieveFileResponse(rsp *http.Response) (*RetrieveFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParsePingResponse parses an HTTP response from a PingWithResponse call
func ParsePingResponse(rsp *http.Response) (*PingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Key Returns the public key used
			Key     *string `json:"key,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Retrieves account related information
	// (GET /account.json)
	Account(w http.ResponseWriter, r *http.Request)
	// Creates a temporary authentication token
	// (POST /auth/tokens)
	CreateToken(w http.ResponseWriter, r *http.Request)
	// Deletes a previously created temporary authentication token
	// (DELETE /auth/tokens/{id})
	DeleteToken(w http.ResponseWriter, r *http.Request, id string)
	// Retrieves a previously created temporary authentication token
	// (GET /auth/tokens/{id})
	RetrieveToken(w http.ResponseWriter, r *http.Request, id string)
	// Submits content for processing
	// (POST /files)
	ProcessFile(w http.ResponseWriter, r *http.Request)
	// Submits content for processing asynchronously
	// (POST /files/async)
	ProcessFileAsync(w http.ResponseWriter, r *http.Request)
	// Submits a URL for processing asynchronously
	// (POST /files/fetch)
	ProcessFileFetch(w http.ResponseWriter, r *http.Request)
	// Retrieves a previously created processing result
	// (GET /files/{id})
	RetrieveFile(w http.ResponseWriter, r *http.Request, id string)
	// Test endpoint
	// (GET /ping)
	Ping(w http.ResponseWriter, r *http.Request)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Retrieves account related information
// (GET /account.json)
func (_ Unimplemented) Account(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Creates a temporary authentication token
// (POST /auth/tokens)
func (_ Unimplemented) CreateToken(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Deletes a previously created temporary authentication token
// (DELETE /auth/tokens/{id})
func (_ Unimplemented) DeleteToken(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Retrieves a previously created temporary authentication token
// (GET /auth/tokens/{id})
func (_ Unimplemented) RetrieveToken(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Submits content for processing
// (POST /files)
func (_ Unimplemented) ProcessFile(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Submits content for processing asynchronously
// (POST /files/async)
func (_ Unimplemented) ProcessFileAsync(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Submits a URL for processing asynchronously
// (POST /files/fetch)
func (_ Unimplemented) ProcessFileFetch(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Retrieves a previously created processing result
// (GET /files/{id})
func (_ Unimplemented) RetrieveFile(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Test endpoint
// (GET /ping)
func (_ Unimplemented) Ping(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// Account operation middleware
func (siw *ServerInterfaceWrapper) Account(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Account(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// CreateToken operation middleware
func (siw *ServerInterfaceWrapper) CreateToken(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateToken(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteToken operation middleware
func (siw *ServerInterfaceWrapper) DeleteToken(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteToken(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// RetrieveToken operation middleware
func (siw *ServerInterfaceWrapper) RetrieveToken(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RetrieveToken(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ProcessFile operation middleware
func (siw *ServerInterfaceWrapper) ProcessFile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ProcessFile(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ProcessFileAsync operation middleware
func (siw *ServerInterfaceWrapper) ProcessFileAsync(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ProcessFileAsync(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ProcessFileFetch operation middleware
func (siw *ServerInterfaceWrapper) ProcessFileFetch(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ProcessFileFetch(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// RetrieveFile operation middleware
func (siw *ServerInterfaceWrapper) RetrieveFile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RetrieveFile(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// Ping operation middleware
func (siw *ServerInterfaceWrapper) Ping(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Ping(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/account.json", wrapper.Account)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/tokens", wrapper.CreateToken)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/tokens/{id}", wrapper.DeleteToken)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/tokens/{id}", wrapper.RetrieveToken)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/files", wrapper.ProcessFile)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/files/async", wrapper.ProcessFileAsync)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/files/fetch", wrapper.ProcessFileFetch)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/files/{id}", wrapper.RetrieveFile)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/ping", wrapper.Ping)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"///LStY/3D0AAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
