// Package v22 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package v22

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"mime/multipart"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	TokenScopes = "token.Scopes"
)

// AccountInfo defines model for AccountInfo.
type AccountInfo struct {
	Balance          *float32           `json:"balance,omitempty"`
	BillingEmail     *string            `json:"billing_email,omitempty"`
	CreationDate     *string            `json:"creation_date,omitempty"`
	Keys             *map[string]ApiKey `json:"keys,omitempty"`
	ModificationDate *string            `json:"modification_date,omitempty"`
	Name             *string            `json:"name,omitempty"`
	StartingBalance  *float32           `json:"starting_balance,omitempty"`
	Subscription     *string            `json:"subscription,omitempty"`
	Users            *map[string]User   `json:"users,omitempty"`
}

// ApiKey defines model for ApiKey.
type ApiKey struct {
	Active                     *bool     `json:"active,omitempty"`
	CreationDate               *string   `json:"creation_date,omitempty"`
	DetectionCategoriesEnabled *[]string `json:"detection_categories_enabled,omitempty"`
	LastSeenDate               *string   `json:"last_seen_date,omitempty"`
	Tags                       *[]string `json:"tags,omitempty"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error    *string                    `json:"error"`
	Id       *string                    `json:"id"`
	Metadata *map[string]MetadataObject `json:"metadata,omitempty"`
}

// MetadataObject Arbitrary set of user-supplied key/value pairs
type MetadataObject map[string]string

// ProcessingPendingResponse Entity representation of a pending content analysis
type ProcessingPendingResponse struct {
	// Id This result unique identifier, should be used to retried the result of the analysis
	Id *string `json:"id,omitempty"`
}

// ProcessingResponse Entity representation the result of a file analysis. Please note that this entity is only returned for
// synchronous requests. For asynchronous requests please refer to the [Files](#tag/Files) resource.
type ProcessingResponse struct {
	// Checksum The SHA1 digest of the content processed
	Checksum *string `json:"checksum,omitempty"`

	// ContentLength The length in bytes of the content processed
	ContentLength *float32 `json:"content_length,omitempty"`

	// ContentType The media type of the content processed
	ContentType *string `json:"content_type,omitempty"`

	// CreationDate ISO8601 time stamp of when the content was processed
	CreationDate *string `json:"creation_date,omitempty"`

	// Findings These are the labels/findings identified by our detection engines using a dot notation for hierarchies, for
	// example: content.malicious.foo or content.malicious.bar. Please note that the actual findings will vary based
	// on the content type and the detection engines enabled for your API key.
	// As of this API version common content hierarchies include:
	//
	// * content.malicious.{{name}} - malicious content like malware and spam
	// * content.images.nsfw.{{name}} - unsafe image
	// * content.{{ISO_3166-1_alpha-2 country code}}.language.nsfw - unsafe language
	//
	// A empty findings array means that no findings were identified for the content processed and it should be considered *safe*.
	Findings *[]string `json:"findings,omitempty"`

	// Id This result unique identifier, should be used to retried the result of the analysis
	Id *string `json:"id,omitempty"`

	// Metadata Arbitrary set of user-supplied key/value pairs
	Metadata *map[string]MetadataObject `json:"metadata,omitempty"`
}

// User defines model for User.
type User struct {
	CreationDate *string `json:"creation_date,omitempty"`
	LastLogin    *string `json:"last_login,omitempty"`
}

// N401 defines model for 401.
type N401 = ErrorResponse

// CreateTokenFormdataBody defines parameters for CreateToken.
type CreateTokenFormdataBody struct {
	// Timeout Number of seconds this token should be valid for
	Timeout *int64 `form:"timeout,omitempty" json:"timeout,omitempty"`
}

// ProcessFileMultipartBody defines parameters for ProcessFile.
type ProcessFileMultipartBody struct {
	// File File to analyze
	File openapi_types.File `json:"file"`

	// Location URL to fetch and analyze
	Location string `json:"location"`

	// Metadata Arbitrary set of user-supplied key/value pairs
	Metadata *MetadataObject `json:"metadata,omitempty"`
}

// ProcessFileAsyncMultipartBody defines parameters for ProcessFileAsync.
type ProcessFileAsyncMultipartBody struct {
	// Callback Callback URL to notify once processing is completed
	Callback *string `json:"callback,omitempty"`

	// File File to analyze
	File *openapi_types.File `json:"file,omitempty"`

	// Metadata Arbitrary set of user-supplied key/value pairs
	Metadata *MetadataObject `json:"metadata,omitempty"`
}

// ProcessFileFetchFormdataBody defines parameters for ProcessFileFetch.
type ProcessFileFetchFormdataBody struct {
	// Callback Callback URL to notify once processing is completed
	Callback *string `form:"callback,omitempty" json:"callback,omitempty"`

	// Location URL to fetch and analyze
	Location *string `form:"location,omitempty" json:"location,omitempty"`

	// Metadata Arbitrary set of user-supplied key/value pairs
	Metadata *MetadataObject `form:"metadata,omitempty" json:"metadata,omitempty"`
}

// CreateTokenFormdataRequestBody defines body for CreateToken for application/x-www-form-urlencoded ContentType.
type CreateTokenFormdataRequestBody CreateTokenFormdataBody

// ProcessFileMultipartRequestBody defines body for ProcessFile for multipart/form-data ContentType.
type ProcessFileMultipartRequestBody ProcessFileMultipartBody

// ProcessFileAsyncMultipartRequestBody defines body for ProcessFileAsync for multipart/form-data ContentType.
type ProcessFileAsyncMultipartRequestBody ProcessFileAsyncMultipartBody

// ProcessFileFetchFormdataRequestBody defines body for ProcessFileFetch for application/x-www-form-urlencoded ContentType.
type ProcessFileFetchFormdataRequestBody ProcessFileFetchFormdataBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Retrieves account related information
	// (GET /account.json)
	Account(w http.ResponseWriter, r *http.Request)
	// Creates a temporary authentication token
	// (POST /auth/tokens)
	CreateToken(w http.ResponseWriter, r *http.Request)
	// Deletes a previously created temporary authentication token
	// (DELETE /auth/tokens/{id})
	DeleteToken(w http.ResponseWriter, r *http.Request, id string)
	// Retrieves a previously created temporary authentication token
	// (GET /auth/tokens/{id})
	GetToken(w http.ResponseWriter, r *http.Request, id string)
	// Submits content for processing
	// (POST /files)
	ProcessFile(w http.ResponseWriter, r *http.Request)
	// Submits content for processing asynchronously
	// (POST /files/async)
	ProcessFileAsync(w http.ResponseWriter, r *http.Request)
	// Submits a URL for processing asynchronously
	// (POST /files/fetch)
	ProcessFileFetch(w http.ResponseWriter, r *http.Request)
	// Retrieves a previously created processing result
	// (GET /files/{id})
	RetrieveFile(w http.ResponseWriter, r *http.Request, id string)
	// Test endpoint
	// (GET /ping)
	Ping(w http.ResponseWriter, r *http.Request)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Retrieves account related information
// (GET /account.json)
func (_ Unimplemented) Account(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Creates a temporary authentication token
// (POST /auth/tokens)
func (_ Unimplemented) CreateToken(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Deletes a previously created temporary authentication token
// (DELETE /auth/tokens/{id})
func (_ Unimplemented) DeleteToken(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Retrieves a previously created temporary authentication token
// (GET /auth/tokens/{id})
func (_ Unimplemented) GetToken(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Submits content for processing
// (POST /files)
func (_ Unimplemented) ProcessFile(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Submits content for processing asynchronously
// (POST /files/async)
func (_ Unimplemented) ProcessFileAsync(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Submits a URL for processing asynchronously
// (POST /files/fetch)
func (_ Unimplemented) ProcessFileFetch(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Retrieves a previously created processing result
// (GET /files/{id})
func (_ Unimplemented) RetrieveFile(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Test endpoint
// (GET /ping)
func (_ Unimplemented) Ping(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// Account operation middleware
func (siw *ServerInterfaceWrapper) Account(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Account(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// CreateToken operation middleware
func (siw *ServerInterfaceWrapper) CreateToken(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateToken(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteToken operation middleware
func (siw *ServerInterfaceWrapper) DeleteToken(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteToken(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetToken operation middleware
func (siw *ServerInterfaceWrapper) GetToken(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetToken(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ProcessFile operation middleware
func (siw *ServerInterfaceWrapper) ProcessFile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ProcessFile(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ProcessFileAsync operation middleware
func (siw *ServerInterfaceWrapper) ProcessFileAsync(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ProcessFileAsync(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ProcessFileFetch operation middleware
func (siw *ServerInterfaceWrapper) ProcessFileFetch(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ProcessFileFetch(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// RetrieveFile operation middleware
func (siw *ServerInterfaceWrapper) RetrieveFile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RetrieveFile(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// Ping operation middleware
func (siw *ServerInterfaceWrapper) Ping(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Ping(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/account.json", wrapper.Account)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/tokens", wrapper.CreateToken)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/tokens/{id}", wrapper.DeleteToken)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/tokens/{id}", wrapper.GetToken)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/files", wrapper.ProcessFile)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/files/async", wrapper.ProcessFileAsync)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/files/fetch", wrapper.ProcessFileFetch)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/files/{id}", wrapper.RetrieveFile)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/ping", wrapper.Ping)
	})

	return r
}

type N401ResponseHeaders struct {
	XScaniiHostId    string
	XScaniiRequestId string
}
type N401JSONResponse struct {
	Body ErrorResponse

	Headers N401ResponseHeaders
}

type AccountRequestObject struct {
}

type AccountResponseObject interface {
	VisitAccountResponse(w http.ResponseWriter) error
}

type Account200ResponseHeaders struct {
	XScaniiHostId    string
	XScaniiRequestId string
}

type Account200JSONResponse struct {
	Body    AccountInfo
	Headers Account200ResponseHeaders
}

func (response Account200JSONResponse) VisitAccountResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type Account401JSONResponse struct{ N401JSONResponse }

func (response Account401JSONResponse) VisitAccountResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateTokenRequestObject struct {
	Body *CreateTokenFormdataRequestBody
}

type CreateTokenResponseObject interface {
	VisitCreateTokenResponse(w http.ResponseWriter) error
}

type CreateToken200ResponseHeaders struct {
	XScaniiHostId    string
	XScaniiRequestId string
}

type CreateToken200JSONResponse struct {
	Body struct {
		CreationDate   *string `json:"creation_date,omitempty"`
		ExpirationDate *string `json:"expiration_date,omitempty"`
		Id             *string `json:"id,omitempty"`
	}
	Headers CreateToken200ResponseHeaders
}

func (response CreateToken200JSONResponse) VisitCreateTokenResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateToken401JSONResponse struct{ N401JSONResponse }

func (response CreateToken401JSONResponse) VisitCreateTokenResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteTokenRequestObject struct {
	Id string `json:"id"`
}

type DeleteTokenResponseObject interface {
	VisitDeleteTokenResponse(w http.ResponseWriter) error
}

type DeleteToken204ResponseHeaders struct {
	XScaniiHostId    string
	XScaniiRequestId string
}

type DeleteToken204Response struct {
	Headers DeleteToken204ResponseHeaders
}

func (response DeleteToken204Response) VisitDeleteTokenResponse(w http.ResponseWriter) error {
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(204)
	return nil
}

type DeleteToken401JSONResponse struct{ N401JSONResponse }

func (response DeleteToken401JSONResponse) VisitDeleteTokenResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetTokenRequestObject struct {
	Id string `json:"id"`
}

type GetTokenResponseObject interface {
	VisitGetTokenResponse(w http.ResponseWriter) error
}

type GetToken200ResponseHeaders struct {
	XScaniiHostId    string
	XScaniiRequestId string
}

type GetToken200JSONResponse struct {
	Body struct {
		CreationDate   *string `json:"creation_date,omitempty"`
		ExpirationDate *string `json:"expiration_date,omitempty"`
		Id             *string `json:"id,omitempty"`
	}
	Headers GetToken200ResponseHeaders
}

func (response GetToken200JSONResponse) VisitGetTokenResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetToken401JSONResponse struct{ N401JSONResponse }

func (response GetToken401JSONResponse) VisitGetTokenResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

type ProcessFileRequestObject struct {
	Body *multipart.Reader
}

type ProcessFileResponseObject interface {
	VisitProcessFileResponse(w http.ResponseWriter) error
}

type ProcessFile201ResponseHeaders struct {
	Location         string
	XScaniiHostId    string
	XScaniiRequestId string
}

type ProcessFile201JSONResponse struct {
	Body    ProcessingResponse
	Headers ProcessFile201ResponseHeaders
}

func (response ProcessFile201JSONResponse) VisitProcessFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response.Body)
}

type ProcessFile400ResponseHeaders struct {
	XScaniiHostId    string
	XScaniiRequestId string
}

type ProcessFile400JSONResponse struct {
	Body    ErrorResponse
	Headers ProcessFile400ResponseHeaders
}

func (response ProcessFile400JSONResponse) VisitProcessFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.Body)
}

type ProcessFile401JSONResponse struct{ N401JSONResponse }

func (response ProcessFile401JSONResponse) VisitProcessFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

type ProcessFile403ResponseHeaders struct {
	XScaniiHostId    string
	XScaniiRequestId string
}

type ProcessFile403JSONResponse struct {
	Body    ErrorResponse
	Headers ProcessFile403ResponseHeaders
}

func (response ProcessFile403JSONResponse) VisitProcessFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response.Body)
}

type ProcessFile413ResponseHeaders struct {
	XScaniiHostId    string
	XScaniiRequestId string
}

type ProcessFile413JSONResponse struct {
	Body    ErrorResponse
	Headers ProcessFile413ResponseHeaders
}

func (response ProcessFile413JSONResponse) VisitProcessFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(413)

	return json.NewEncoder(w).Encode(response.Body)
}

type ProcessFileAsyncRequestObject struct {
	Body *multipart.Reader
}

type ProcessFileAsyncResponseObject interface {
	VisitProcessFileAsyncResponse(w http.ResponseWriter) error
}

type ProcessFileAsync202ResponseHeaders struct {
	Location         string
	XScaniiHostId    string
	XScaniiRequestId string
}

type ProcessFileAsync202JSONResponse struct {
	Body    ProcessingPendingResponse
	Headers ProcessFileAsync202ResponseHeaders
}

func (response ProcessFileAsync202JSONResponse) VisitProcessFileAsyncResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(202)

	return json.NewEncoder(w).Encode(response.Body)
}

type ProcessFileAsync400ResponseHeaders struct {
	XScaniiHostId    string
	XScaniiRequestId string
}

type ProcessFileAsync400JSONResponse struct {
	Body    ErrorResponse
	Headers ProcessFileAsync400ResponseHeaders
}

func (response ProcessFileAsync400JSONResponse) VisitProcessFileAsyncResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.Body)
}

type ProcessFileAsync401JSONResponse struct{ N401JSONResponse }

func (response ProcessFileAsync401JSONResponse) VisitProcessFileAsyncResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

type ProcessFileFetchRequestObject struct {
	Body *ProcessFileFetchFormdataRequestBody
}

type ProcessFileFetchResponseObject interface {
	VisitProcessFileFetchResponse(w http.ResponseWriter) error
}

type ProcessFileFetch202ResponseHeaders struct {
	Location         string
	XScaniiHostId    string
	XScaniiRequestId string
}

type ProcessFileFetch202JSONResponse struct {
	Body    ProcessingPendingResponse
	Headers ProcessFileFetch202ResponseHeaders
}

func (response ProcessFileFetch202JSONResponse) VisitProcessFileFetchResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(202)

	return json.NewEncoder(w).Encode(response.Body)
}

type ProcessFileFetch400ResponseHeaders struct {
	XScaniiHostId    string
	XScaniiRequestId string
}

type ProcessFileFetch400JSONResponse struct {
	Body    ErrorResponse
	Headers ProcessFileFetch400ResponseHeaders
}

func (response ProcessFileFetch400JSONResponse) VisitProcessFileFetchResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.Body)
}

type ProcessFileFetch401JSONResponse struct{ N401JSONResponse }

func (response ProcessFileFetch401JSONResponse) VisitProcessFileFetchResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

type RetrieveFileRequestObject struct {
	Id string `json:"id"`
}

type RetrieveFileResponseObject interface {
	VisitRetrieveFileResponse(w http.ResponseWriter) error
}

type RetrieveFile200ResponseHeaders struct {
	XScaniiHostId    string
	XScaniiRequestId string
}

type RetrieveFile200JSONResponse struct {
	Body    ProcessingResponse
	Headers RetrieveFile200ResponseHeaders
}

func (response RetrieveFile200JSONResponse) VisitRetrieveFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type RetrieveFile401JSONResponse struct{ N401JSONResponse }

func (response RetrieveFile401JSONResponse) VisitRetrieveFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

type PingRequestObject struct {
}

type PingResponseObject interface {
	VisitPingResponse(w http.ResponseWriter) error
}

type Ping200ResponseHeaders struct {
	XScaniiHostId    string
	XScaniiRequestId string
}

type Ping200JSONResponse struct {
	Body struct {
		// Key Returns the public key used
		Key     *string `json:"key,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	Headers Ping200ResponseHeaders
}

func (response Ping200JSONResponse) VisitPingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type Ping401JSONResponse struct{ N401JSONResponse }

func (response Ping401JSONResponse) VisitPingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Scanii-Host-Id", fmt.Sprint(response.Headers.XScaniiHostId))
	w.Header().Set("X-Scanii-Request-Id", fmt.Sprint(response.Headers.XScaniiRequestId))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Retrieves account related information
	// (GET /account.json)
	Account(ctx context.Context, request AccountRequestObject) (AccountResponseObject, error)
	// Creates a temporary authentication token
	// (POST /auth/tokens)
	CreateToken(ctx context.Context, request CreateTokenRequestObject) (CreateTokenResponseObject, error)
	// Deletes a previously created temporary authentication token
	// (DELETE /auth/tokens/{id})
	DeleteToken(ctx context.Context, request DeleteTokenRequestObject) (DeleteTokenResponseObject, error)
	// Retrieves a previously created temporary authentication token
	// (GET /auth/tokens/{id})
	GetToken(ctx context.Context, request GetTokenRequestObject) (GetTokenResponseObject, error)
	// Submits content for processing
	// (POST /files)
	ProcessFile(ctx context.Context, request ProcessFileRequestObject) (ProcessFileResponseObject, error)
	// Submits content for processing asynchronously
	// (POST /files/async)
	ProcessFileAsync(ctx context.Context, request ProcessFileAsyncRequestObject) (ProcessFileAsyncResponseObject, error)
	// Submits a URL for processing asynchronously
	// (POST /files/fetch)
	ProcessFileFetch(ctx context.Context, request ProcessFileFetchRequestObject) (ProcessFileFetchResponseObject, error)
	// Retrieves a previously created processing result
	// (GET /files/{id})
	RetrieveFile(ctx context.Context, request RetrieveFileRequestObject) (RetrieveFileResponseObject, error)
	// Test endpoint
	// (GET /ping)
	Ping(ctx context.Context, request PingRequestObject) (PingResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHttpHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHttpMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// Account operation middleware
func (sh *strictHandler) Account(w http.ResponseWriter, r *http.Request) {
	var request AccountRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.Account(ctx, request.(AccountRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "Account")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AccountResponseObject); ok {
		if err := validResponse.VisitAccountResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateToken operation middleware
func (sh *strictHandler) CreateToken(w http.ResponseWriter, r *http.Request) {
	var request CreateTokenRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body CreateTokenFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreateToken(ctx, request.(CreateTokenRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateToken")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreateTokenResponseObject); ok {
		if err := validResponse.VisitCreateTokenResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteToken operation middleware
func (sh *strictHandler) DeleteToken(w http.ResponseWriter, r *http.Request, id string) {
	var request DeleteTokenRequestObject

	request.Id = id

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteToken(ctx, request.(DeleteTokenRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteToken")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteTokenResponseObject); ok {
		if err := validResponse.VisitDeleteTokenResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetToken operation middleware
func (sh *strictHandler) GetToken(w http.ResponseWriter, r *http.Request, id string) {
	var request GetTokenRequestObject

	request.Id = id

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetToken(ctx, request.(GetTokenRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetToken")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetTokenResponseObject); ok {
		if err := validResponse.VisitGetTokenResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ProcessFile operation middleware
func (sh *strictHandler) ProcessFile(w http.ResponseWriter, r *http.Request) {
	var request ProcessFileRequestObject

	if reader, err := r.MultipartReader(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode multipart body: %w", err))
		return
	} else {
		request.Body = reader
	}

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ProcessFile(ctx, request.(ProcessFileRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ProcessFile")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ProcessFileResponseObject); ok {
		if err := validResponse.VisitProcessFileResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ProcessFileAsync operation middleware
func (sh *strictHandler) ProcessFileAsync(w http.ResponseWriter, r *http.Request) {
	var request ProcessFileAsyncRequestObject

	if reader, err := r.MultipartReader(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode multipart body: %w", err))
		return
	} else {
		request.Body = reader
	}

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ProcessFileAsync(ctx, request.(ProcessFileAsyncRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ProcessFileAsync")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ProcessFileAsyncResponseObject); ok {
		if err := validResponse.VisitProcessFileAsyncResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ProcessFileFetch operation middleware
func (sh *strictHandler) ProcessFileFetch(w http.ResponseWriter, r *http.Request) {
	var request ProcessFileFetchRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body ProcessFileFetchFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ProcessFileFetch(ctx, request.(ProcessFileFetchRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ProcessFileFetch")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ProcessFileFetchResponseObject); ok {
		if err := validResponse.VisitProcessFileFetchResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// RetrieveFile operation middleware
func (sh *strictHandler) RetrieveFile(w http.ResponseWriter, r *http.Request, id string) {
	var request RetrieveFileRequestObject

	request.Id = id

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.RetrieveFile(ctx, request.(RetrieveFileRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RetrieveFile")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(RetrieveFileResponseObject); ok {
		if err := validResponse.VisitRetrieveFileResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Ping operation middleware
func (sh *strictHandler) Ping(w http.ResponseWriter, r *http.Request) {
	var request PingRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.Ping(ctx, request.(PingRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "Ping")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PingResponseObject); ok {
		if err := validResponse.VisitPingResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
