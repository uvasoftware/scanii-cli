// Package v22 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package v22

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	TokenScopes = "token.Scopes"
)

// AccountInfo defines model for AccountInfo.
type AccountInfo struct {
	Balance          *float32           `json:"balance,omitempty"`
	BillingEmail     *string            `json:"billing_email,omitempty"`
	CreationDate     *string            `json:"creation_date,omitempty"`
	Keys             *map[string]ApiKey `json:"keys,omitempty"`
	ModificationDate *string            `json:"modification_date,omitempty"`
	Name             *string            `json:"name,omitempty"`
	StartingBalance  *float32           `json:"starting_balance,omitempty"`
	Subscription     *string            `json:"subscription,omitempty"`
	Users            *map[string]User   `json:"users,omitempty"`
}

// ApiKey defines model for ApiKey.
type ApiKey struct {
	Active                     *bool     `json:"active,omitempty"`
	CreationDate               *string   `json:"creation_date,omitempty"`
	DetectionCategoriesEnabled *[]string `json:"detection_categories_enabled,omitempty"`
	LastSeenDate               *string   `json:"last_seen_date,omitempty"`
	Tags                       *[]string `json:"tags,omitempty"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error    *string            `json:"error"`
	Id       *string            `json:"id"`
	Metadata *map[string]string `json:"metadata,omitempty"`
}

// ProcessingPendingResponse Entity representation of a pending content analysis
type ProcessingPendingResponse struct {
	// Id This result unique identifier, should be used to retried the result of the analysis
	Id *string `json:"id,omitempty"`
}

// ProcessingResponse Entity representation the result of a file analysis. Please note that this entity is only returned for
// synchronous requests. For asynchronous requests please refer to the [Files](#tag/Files) resource.
type ProcessingResponse struct {
	// Checksum The SHA1 digest of the content processed
	Checksum *string `json:"checksum"`

	// ContentLength The length in bytes of the content processed
	ContentLength *float32 `json:"content_length"`

	// ContentType The media type of the content processed
	ContentType *string `json:"content_type"`

	// CreationDate ISO8601 time stamp of when the content was processed
	CreationDate *string `json:"creation_date"`

	// Error If an error occurred during processing this field will contain the error message. Please note that this field is only
	// present if an error occurred during processing.
	Error *string `json:"error"`

	// Findings These are the labels/findings identified by our detection engines using a dot notation for hierarchies, for
	// example: content.malicious.foo or content.malicious.bar. Please note that the actual findings will vary based
	// on the content type and the detection engines enabled for your API key.
	// As of this API version common content hierarchies include:
	//
	// * content.malicious.{{name}} - malicious content like malware and spam
	// * content.images.nsfw.{{name}} - unsafe image
	// * content.{{ISO_3166-1_alpha-2 country code}}.language.nsfw - unsafe language
	//
	// A empty findings array means that no findings were identified for the content processed and it should be considered *safe*.
	Findings *[]string `json:"findings"`

	// Id This result unique identifier, should be used to retried the result of the analysis
	Id       *string            `json:"id,omitempty"`
	Metadata *map[string]string `json:"metadata,omitempty"`
}

// User defines model for User.
type User struct {
	CreationDate *string `json:"creation_date,omitempty"`
	LastLogin    *string `json:"last_login,omitempty"`
}

// N401 defines model for 401.
type N401 = ErrorResponse

// CreateTokenFormdataBody defines parameters for CreateToken.
type CreateTokenFormdataBody struct {
	// Timeout Number of seconds this token should be valid for
	Timeout *int64 `form:"timeout,omitempty" json:"timeout,omitempty"`
}

// ProcessFileMultipartBody defines parameters for ProcessFile.
type ProcessFileMultipartBody struct {
	// File File to analyze
	File openapi_types.File `json:"file"`

	// Location URL to fetch and analyze
	Location string             `json:"location"`
	Metadata *map[string]string `json:"metadata,omitempty"`
}

// ProcessFileAsyncMultipartBody defines parameters for ProcessFileAsync.
type ProcessFileAsyncMultipartBody struct {
	// Callback Callback URL to notify once processing is completed
	Callback *string `json:"callback,omitempty"`

	// File File to analyze
	File     *openapi_types.File `json:"file,omitempty"`
	Metadata *map[string]string  `json:"metadata,omitempty"`
}

// ProcessFileFetchFormdataBody defines parameters for ProcessFileFetch.
type ProcessFileFetchFormdataBody struct {
	// Callback Callback URL to notify once processing is completed
	Callback *string `form:"callback,omitempty" json:"callback,omitempty"`

	// Location URL to fetch and analyze
	Location             *string           `form:"location,omitempty" json:"location,omitempty"`
	AdditionalProperties map[string]string `json:"-"`
}

// CreateTokenFormdataRequestBody defines body for CreateToken for application/x-www-form-urlencoded ContentType.
type CreateTokenFormdataRequestBody CreateTokenFormdataBody

// ProcessFileMultipartRequestBody defines body for ProcessFile for multipart/form-data ContentType.
type ProcessFileMultipartRequestBody ProcessFileMultipartBody

// ProcessFileAsyncMultipartRequestBody defines body for ProcessFileAsync for multipart/form-data ContentType.
type ProcessFileAsyncMultipartRequestBody ProcessFileAsyncMultipartBody

// ProcessFileFetchFormdataRequestBody defines body for ProcessFileFetch for application/x-www-form-urlencoded ContentType.
type ProcessFileFetchFormdataRequestBody ProcessFileFetchFormdataBody

// Getter for additional properties for ProcessFileFetchFormdataBody. Returns the specified
// element and whether it was found
func (a ProcessFileFetchFormdataBody) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ProcessFileFetchFormdataBody
func (a *ProcessFileFetchFormdataBody) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ProcessFileFetchFormdataBody to handle AdditionalProperties
func (a *ProcessFileFetchFormdataBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["callback"]; found {
		err = json.Unmarshal(raw, &a.Callback)
		if err != nil {
			return fmt.Errorf("error reading 'callback': %w", err)
		}
		delete(object, "callback")
	}

	if raw, found := object["location"]; found {
		err = json.Unmarshal(raw, &a.Location)
		if err != nil {
			return fmt.Errorf("error reading 'location': %w", err)
		}
		delete(object, "location")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ProcessFileFetchFormdataBody to handle AdditionalProperties
func (a ProcessFileFetchFormdataBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Callback != nil {
		object["callback"], err = json.Marshal(a.Callback)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'callback': %w", err)
		}
	}

	if a.Location != nil {
		object["location"], err = json.Marshal(a.Location)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'location': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// Account request
	Account(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTokenWithBody request with any body
	CreateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTokenWithFormdataBody(ctx context.Context, body CreateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteToken request
	DeleteToken(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetToken request
	GetToken(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProcessFileWithBody request with any body
	ProcessFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProcessFileAsyncWithBody request with any body
	ProcessFileAsyncWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProcessFileFetchWithBody request with any body
	ProcessFileFetchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProcessFileFetchWithFormdataBody(ctx context.Context, body ProcessFileFetchFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveFile request
	RetrieveFile(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Ping request
	Ping(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) Account(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTokenWithFormdataBody(ctx context.Context, body CreateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteToken(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTokenRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetToken(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTokenRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProcessFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessFileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProcessFileAsyncWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessFileAsyncRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProcessFileFetchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessFileFetchRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProcessFileFetchWithFormdataBody(ctx context.Context, body ProcessFileFetchFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessFileFetchRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveFile(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveFileRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Ping(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPingRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAccountRequest generates requests for Account
func NewAccountRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/account.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTokenRequestWithFormdataBody calls the generic CreateToken builder with application/x-www-form-urlencoded body
func NewCreateTokenRequestWithFormdataBody(server string, body CreateTokenFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewCreateTokenRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewCreateTokenRequestWithBody generates requests for CreateToken with any type of body
func NewCreateTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTokenRequest generates requests for DeleteToken
func NewDeleteTokenRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/tokens/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTokenRequest generates requests for GetToken
func NewGetTokenRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/tokens/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProcessFileRequestWithBody generates requests for ProcessFile with any type of body
func NewProcessFileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProcessFileAsyncRequestWithBody generates requests for ProcessFileAsync with any type of body
func NewProcessFileAsyncRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/async")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProcessFileFetchRequestWithFormdataBody calls the generic ProcessFileFetch builder with application/x-www-form-urlencoded body
func NewProcessFileFetchRequestWithFormdataBody(server string, body ProcessFileFetchFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewProcessFileFetchRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewProcessFileFetchRequestWithBody generates requests for ProcessFileFetch with any type of body
func NewProcessFileFetchRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/fetch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRetrieveFileRequest generates requests for RetrieveFile
func NewRetrieveFileRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPingRequest generates requests for Ping
func NewPingRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ping")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AccountWithResponse request
	AccountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AccountResponse, error)

	// CreateTokenWithBodyWithResponse request with any body
	CreateTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	CreateTokenWithFormdataBodyWithResponse(ctx context.Context, body CreateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	// DeleteTokenWithResponse request
	DeleteTokenWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteTokenResponse, error)

	// GetTokenWithResponse request
	GetTokenWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetTokenResponse, error)

	// ProcessFileWithBodyWithResponse request with any body
	ProcessFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessFileResponse, error)

	// ProcessFileAsyncWithBodyWithResponse request with any body
	ProcessFileAsyncWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessFileAsyncResponse, error)

	// ProcessFileFetchWithBodyWithResponse request with any body
	ProcessFileFetchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessFileFetchResponse, error)

	ProcessFileFetchWithFormdataBodyWithResponse(ctx context.Context, body ProcessFileFetchFormdataRequestBody, reqEditors ...RequestEditorFn) (*ProcessFileFetchResponse, error)

	// RetrieveFileWithResponse request
	RetrieveFileWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RetrieveFileResponse, error)

	// PingWithResponse request
	PingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PingResponse, error)
}

type AccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountInfo
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r AccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CreationDate   *string `json:"creation_date,omitempty"`
		ExpirationDate *string `json:"expiration_date,omitempty"`
		Id             *string `json:"id,omitempty"`
	}
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r DeleteTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CreationDate   *string `json:"creation_date,omitempty"`
		ExpirationDate *string `json:"expiration_date,omitempty"`
		Id             *string `json:"id,omitempty"`
	}
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r GetTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProcessFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ProcessingResponse
	JSON400      *ErrorResponse
	JSON401      *N401
	JSON403      *ErrorResponse
	JSON413      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ProcessFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProcessFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProcessFileAsyncResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *ProcessingPendingResponse
	JSON400      *ErrorResponse
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r ProcessFileAsyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProcessFileAsyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProcessFileFetchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *ProcessingPendingResponse
	JSON400      *ErrorResponse
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r ProcessFileFetchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProcessFileFetchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProcessingResponse
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r RetrieveFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Key Returns the public key used
		Key     *string `json:"key,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r PingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AccountWithResponse request returning *AccountResponse
func (c *ClientWithResponses) AccountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AccountResponse, error) {
	rsp, err := c.Account(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountResponse(rsp)
}

// CreateTokenWithBodyWithResponse request with arbitrary body returning *CreateTokenResponse
func (c *ClientWithResponses) CreateTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateTokenWithFormdataBodyWithResponse(ctx context.Context, body CreateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateTokenWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

// DeleteTokenWithResponse request returning *DeleteTokenResponse
func (c *ClientWithResponses) DeleteTokenWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteTokenResponse, error) {
	rsp, err := c.DeleteToken(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTokenResponse(rsp)
}

// GetTokenWithResponse request returning *GetTokenResponse
func (c *ClientWithResponses) GetTokenWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetTokenResponse, error) {
	rsp, err := c.GetToken(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTokenResponse(rsp)
}

// ProcessFileWithBodyWithResponse request with arbitrary body returning *ProcessFileResponse
func (c *ClientWithResponses) ProcessFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessFileResponse, error) {
	rsp, err := c.ProcessFileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessFileResponse(rsp)
}

// ProcessFileAsyncWithBodyWithResponse request with arbitrary body returning *ProcessFileAsyncResponse
func (c *ClientWithResponses) ProcessFileAsyncWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessFileAsyncResponse, error) {
	rsp, err := c.ProcessFileAsyncWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessFileAsyncResponse(rsp)
}

// ProcessFileFetchWithBodyWithResponse request with arbitrary body returning *ProcessFileFetchResponse
func (c *ClientWithResponses) ProcessFileFetchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessFileFetchResponse, error) {
	rsp, err := c.ProcessFileFetchWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessFileFetchResponse(rsp)
}

func (c *ClientWithResponses) ProcessFileFetchWithFormdataBodyWithResponse(ctx context.Context, body ProcessFileFetchFormdataRequestBody, reqEditors ...RequestEditorFn) (*ProcessFileFetchResponse, error) {
	rsp, err := c.ProcessFileFetchWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessFileFetchResponse(rsp)
}

// RetrieveFileWithResponse request returning *RetrieveFileResponse
func (c *ClientWithResponses) RetrieveFileWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RetrieveFileResponse, error) {
	rsp, err := c.RetrieveFile(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveFileResponse(rsp)
}

// PingWithResponse request returning *PingResponse
func (c *ClientWithResponses) PingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PingResponse, error) {
	rsp, err := c.Ping(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePingResponse(rsp)
}

// ParseAccountResponse parses an HTTP response from a AccountWithResponse call
func ParseAccountResponse(rsp *http.Response) (*AccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateTokenResponse parses an HTTP response from a CreateTokenWithResponse call
func ParseCreateTokenResponse(rsp *http.Response) (*CreateTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CreationDate   *string `json:"creation_date,omitempty"`
			ExpirationDate *string `json:"expiration_date,omitempty"`
			Id             *string `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteTokenResponse parses an HTTP response from a DeleteTokenWithResponse call
func ParseDeleteTokenResponse(rsp *http.Response) (*DeleteTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetTokenResponse parses an HTTP response from a GetTokenWithResponse call
func ParseGetTokenResponse(rsp *http.Response) (*GetTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CreationDate   *string `json:"creation_date,omitempty"`
			ExpirationDate *string `json:"expiration_date,omitempty"`
			Id             *string `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseProcessFileResponse parses an HTTP response from a ProcessFileWithResponse call
func ParseProcessFileResponse(rsp *http.Response) (*ProcessFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProcessFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ProcessingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	}

	return response, nil
}

// ParseProcessFileAsyncResponse parses an HTTP response from a ProcessFileAsyncWithResponse call
func ParseProcessFileAsyncResponse(rsp *http.Response) (*ProcessFileAsyncResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProcessFileAsyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ProcessingPendingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseProcessFileFetchResponse parses an HTTP response from a ProcessFileFetchWithResponse call
func ParseProcessFileFetchResponse(rsp *http.Response) (*ProcessFileFetchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProcessFileFetchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ProcessingPendingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRetrieveFileResponse parses an HTTP response from a RetrieveFileWithResponse call
func ParseRetrieveFileResponse(rsp *http.Response) (*RetrieveFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParsePingResponse parses an HTTP response from a PingWithResponse call
func ParsePingResponse(rsp *http.Response) (*PingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Key Returns the public key used
			Key     *string `json:"key,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Retrieves account related information
	// (GET /account.json)
	Account(w http.ResponseWriter, r *http.Request)
	// Creates a temporary authentication token
	// (POST /auth/tokens)
	CreateToken(w http.ResponseWriter, r *http.Request)
	// Deletes a previously created temporary authentication token
	// (DELETE /auth/tokens/{id})
	DeleteToken(w http.ResponseWriter, r *http.Request, id string)
	// Retrieves a previously created temporary authentication token
	// (GET /auth/tokens/{id})
	GetToken(w http.ResponseWriter, r *http.Request, id string)
	// Submits content for processing
	// (POST /files)
	ProcessFile(w http.ResponseWriter, r *http.Request)
	// Submits content for processing asynchronously
	// (POST /files/async)
	ProcessFileAsync(w http.ResponseWriter, r *http.Request)
	// Submits a URL for processing asynchronously
	// (POST /files/fetch)
	ProcessFileFetch(w http.ResponseWriter, r *http.Request)
	// Retrieves a previously created processing result
	// (GET /files/{id})
	RetrieveFile(w http.ResponseWriter, r *http.Request, id string)
	// Test endpoint
	// (GET /ping)
	Ping(w http.ResponseWriter, r *http.Request)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Retrieves account related information
// (GET /account.json)
func (_ Unimplemented) Account(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Creates a temporary authentication token
// (POST /auth/tokens)
func (_ Unimplemented) CreateToken(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Deletes a previously created temporary authentication token
// (DELETE /auth/tokens/{id})
func (_ Unimplemented) DeleteToken(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Retrieves a previously created temporary authentication token
// (GET /auth/tokens/{id})
func (_ Unimplemented) GetToken(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Submits content for processing
// (POST /files)
func (_ Unimplemented) ProcessFile(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Submits content for processing asynchronously
// (POST /files/async)
func (_ Unimplemented) ProcessFileAsync(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Submits a URL for processing asynchronously
// (POST /files/fetch)
func (_ Unimplemented) ProcessFileFetch(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Retrieves a previously created processing result
// (GET /files/{id})
func (_ Unimplemented) RetrieveFile(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Test endpoint
// (GET /ping)
func (_ Unimplemented) Ping(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// Account operation middleware
func (siw *ServerInterfaceWrapper) Account(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Account(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// CreateToken operation middleware
func (siw *ServerInterfaceWrapper) CreateToken(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateToken(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteToken operation middleware
func (siw *ServerInterfaceWrapper) DeleteToken(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteToken(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetToken operation middleware
func (siw *ServerInterfaceWrapper) GetToken(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetToken(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ProcessFile operation middleware
func (siw *ServerInterfaceWrapper) ProcessFile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ProcessFile(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ProcessFileAsync operation middleware
func (siw *ServerInterfaceWrapper) ProcessFileAsync(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ProcessFileAsync(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ProcessFileFetch operation middleware
func (siw *ServerInterfaceWrapper) ProcessFileFetch(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ProcessFileFetch(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// RetrieveFile operation middleware
func (siw *ServerInterfaceWrapper) RetrieveFile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RetrieveFile(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// Ping operation middleware
func (siw *ServerInterfaceWrapper) Ping(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Ping(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/account.json", wrapper.Account)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/tokens", wrapper.CreateToken)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/tokens/{id}", wrapper.DeleteToken)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/tokens/{id}", wrapper.GetToken)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/files", wrapper.ProcessFile)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/files/async", wrapper.ProcessFileAsync)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/files/fetch", wrapper.ProcessFileFetch)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/files/{id}", wrapper.RetrieveFile)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/ping", wrapper.Ping)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xbe2/cNhL/KgP1gCbBetd2iuCwwOHOTdPW16A14qR3hW0klDSSWFOkyoc3e8F+98OQ",
	"lFa7ku2N8yrS/JWNJHLeM78Z0m+STNWNkiitSeZvkgpZjtr/fKoyZrmS9DtHk2nehP8mL549BatAo9Uc",
	"rxBshdBolaExXJag0Thhk0lisgprRuvtssFknhiruSyT1WqS/HfvNGOS870flbF7x/kIFcn/cAg8R2l5",
	"wVGDKjwpg/oKNdiK2ZYs5v6Nxj8cGjuF5xU3wA04g4UTUCgNOaauLIm/xulGGTTTZJLQCq4xT+ZWO9yR",
	"5WeBzNtx/SF5W9HHplHSoDfdN/sH9E+mpEVp6SdrGsGDPWe/m2DU9X5/01gk8+Sr2doZZuGtmT3RWuln",
	"cfdAa1Pib1kOmUYvMBNm4qU9OjmGS1zODGYaLWSqTrn05El05LZCDVxeMcFzUBqcdIalApNJ3wXHnGSM",
	"17hkNvj+eqvttE1vycpLHpVCGxxlmXLSHstC0X8brRrUlgcDpEwwmWHPVtLVKWpiKOVCcFm+xJpxMWLN",
	"SZJp9Kp6mTPr9yiUrplN5gk36u+P9g+SyXDRJS49aZbnnBYzcbLB0k02Pmr4T7ikXeK2Kv0dM0sPapXz",
	"InrOW/EjWY2j0hnLtCUF3KQk49Kej43s4kz0kbvI+8IEKlvSjskfVTOwMMssv+rzniolkMk72y9Hi5lf",
	"lTGLpdIczUuUFBTeYbnF2oyqIj5gWjNvQ8GMfWkQ346+ZaV5GzpjytrMFQOdIb2mH9IJ4aM9ZrYBKZ7v",
	"9FmNluXMspv84DoxbjL6SVfMTlDmXJZ9mTaz3xNpuV2CxkajQWlDjlMFMGjCWohpGJhkYmm4SSZbeuEj",
	"dcRXiVBJwW3XlAmYSjmRQ4pURvJ1NW7roF8XK0+P7rCo3SD72wq9SZlBwcWa+BROBDKDIJXFULstiYhh",
	"K25ASUFbWqcl5lQWz6VZyqzSSipn2vpppvC90sDGXkETSGgsCB8oz9HZ91ygubj3lWXlzP++T1wqpzOc",
	"nsuBMbIKs0vj6jGTIJz+eHQAOS/RdOptzdtBkWRyu+fGRS8FytJW47TCO+AS0qVFcwd663za0gsvxqjV",
	"mHMG9P7dBNvOfZuUjk9/oQQEltcIxrK6IWqLCuUGyQUzG2RHEtitnHTZZouDApgE/xJUljmtMYfcaY++",
	"1iDWO2fBUeSw4EJ4zhgPXIbFNRrDSrzOscPa6NfnMkYK8J3IB8e8VcSC+wxjRi1qEJgO4FywFIWZtZ+v",
	"M0kO6RKUIwQaqw+gLLlEgqfEEoNcWRIthDiB1YqjZjqrOJqJf3Au8TWrG4Hz1n7TmgmeceXMtFCK8N3w",
	"Rcr0qOoQWGYdE9Bx6/V/xfQSUmYwP5dq01m8zzIZUt9QkFhDPatLkjVi0+m5PIpBxY1/eIXa0MpM1bX/",
	"J+zfExi4zITLcQ7n8lw+GBHrzRsCPqsV7EH3sNtJ8EukxwsyDHFsGlZDfyNesxLNVJpi0d/KScMKBP92",
	"4/s3b45Pf3n58ODRo72Dl0w0Fds7BA9M9RIyleNqNRVMlo48lXZdb9Y+JkmOAOvGLtc690UeamTSBMNI",
	"1TMIauz7EGl2NGF4GbntVatMScNzJKd/QFw8mIJ39etRxzVB0KGdT1Y8Pxz88PB0gJ7uhCo9FhSq5HK3",
	"FaMMGsyc5nZ5SvA5iqUucWQy8IvTvj3nmdetoYjlGTBnK1J/aCPgnqL+/fnT0/vedTbfTuE35SBjkjYA",
	"JpdtvAIz3iKE/CkwupBv38deM37WMGMWSufTdhDhQTqxs5a6srYJLS2PbZxP85lvmWN/lhjXNErbf7kr",
	"ZlRhKXanmaqTtsVJXlwxOI1v4OnTx3AvtI/3k0nitIh0zHw2WywWU+Pf+R0GrTRJ0gbT2frDi3vtButn",
	"97toaz07Kjeqf0phPUyvymu1y3hL5aB2xkLBtbFgeCld41lYU/J69s5HKu+yZ2emzVfnkhMPmZK5oeIS",
	"vJYqiQQWWmZgdly6TfXcn8J3KnN1hy+JWIpQKEdZRYa61f/iXBpucQ5n7Ya5ysx0jNLWi/ukrJ8Rc6hQ",
	"NP+Ef5NKvP3hGuv7BcpSYoKsYrJEA4VWNTQar3zOj8Vkfi4BHsBRTA8BGYs4WgOmS88+GaaPaDMmhGll",
	"9KC1w6yGSB9TuV1rhgxs5lQXRgvqgi1hgVAxmQsCeiFrETZJl12dNw1mnAkSoOCvIUIdyhjE86t21Vmh",
	"1MU/UqZfEWrTCK8KpV7RXvS5D1OZwyv/QXx4xYQjf/RZOVdo5NcWatbAAoUgyWtFaLpByRoOJUrUzCpt",
	"wCgwqqaKKQkQsPx3Z7wvxdwcP8XcVzqoeVlZ8pB2cDaF/yA0gkkgVee57mM7LqlFcdZpWuDVFlCX4BnG",
	"ricG+FHDsgr3Dqf7g4guua1cSh4x63nILAozS4VKZzXjcvb0+PGTn0+f+ArALZWzJGQJeBzj+Hgzjo9O",
	"jpNJEr0omSeHU6K/miRx72SePJzuTx9SA8Ns5bPyLEbYtB3xlWiHSfpZnNuaLiA1Cq9GyoJUIeg7T0j7",
	"38c5KSF8m2yNGg/399/bqLE/UhsZND7zveFtXP9px4eTdiw7trbT6Yw+8kXX1TXTy7ewV5jgnCU/+LAQ",
	"yQVtM6PqOvPl2uukUcZbadO4j30Of+6Lehg8o7Hfqnx5g21f7y0Wiz1iYM9pgZJiMN809iaAoZ5PueiQ",
	"BXOCkMjDfQqqTUP/7NtWivK2kPiI9UL0wFsYHhdKbzSI0j76Zl3hubRYUgs8AmxW2yP21Tv69i14bdih",
	"vm64vuWbAG9vR2lj0dJ6zejhzOcXJ8GJSV6LdaM0dYxbyNNGD29D5WjzdQiAQdzM3vB8FdxWYLDTZvh8",
	"55+34dMwzWq0Xrln28l3PV4DnlPjQw8pga/xpH++++HPxcBrvxnpiELsuIyIF06IJQRh8s/SFYJBgusH",
	"PCYiFKUm7x29Y4DaR3YxYfaiuiaTUDG3zn/iwcei4lnlAfiCBQBYav9jzZ03Fr0Jyvk6YHY/1+Q6h4Zp",
	"uwyHZ1Y7Q6JFiDiF59SOM6kkz5iAOJ+BFD3WE0It6AftFpCmVVCxpkEZQCzrbbnAFFKtFoYysgwTlBQr",
	"JooAoXxziFAwU/nu7Vgaiyz32bviTUOE/CKNTLTdg2mns5ngKO3XpiUx8RppgR2FMq8RUg/5x6w1hXM5",
	"rv+KXSEIXnNr5nAuD7xOlqQUqWy/9++IKX8oyUZ3O7x2ebQSy2suubGUFa5wjdaTSQvCNlPGD2h3yhck",
	"XKx8HyxffDZVbhjqUcWfNSj8EDmOKmBBfWcfM26q/tSlFFzdHKJQug804hl/ugRaHtouDGdC7Yqca8ys",
	"8DmsYbEoUk6JF0wKtFk1HBLPe/2zzMOW6xjyibd21jEqcvg6E87wK5wOGppYiam7vhHz1k5YTrl25rFu",
	"O/BbB8T46K9gwuD24RLxOtQkseBTiWRi+T/sw9mUS7L32GTvtus5XnteQ+t9P9QIc519zoKMPf4u7oS8",
	"398FlpEDzZFEchR0ZHqntXk8jdwBQffvSt2UBbrvrrkB9WkT0f7HvTQUQ+5zSc/07cOPp8HfekdZZguX",
	"/MlVevAR1dRO14yvVjaeVvXC2Q8WFAimyz/97bOu+t9ce3vl3c+O+/V85m9OXF/VqXGIlxC7s1GUeaO4",
	"tEFXoX9Yn776Huda9S64rZSzkAqVXbYogJoOxCmEu5BMGAW8bgRH03sdDiaEUpeu6R/MhYE1eX9817I3",
	"IRyx4BoDiKBdUpZdUgdTKXV5IwI48lp5JxiwhYsj9aGGH7d8xTotleXFEpTMcMsvyTnaHn3k7P+9QYkP",
	"c465S5U//ABVfvvK1lixzzJshs76paZ/qek3tFy3NDz9K2lieWMO9tD8+hz8WNUNk6Fb84nOb93Lczak",
	"TaEWJhzW9o4OexypouPVWKXDFIqBxppaqR+fPz/pOqkbk+P3nt33eC5wXZLpctXgtHEsbX3khPs+Gq4v",
	"WfJLlvyLZMkwxbl7jmzPXG47wh6bfo1165vZrd0gTn8++ZHN/kced/z1Tgfv4DJjztmQBa9zy+dobDf6",
	"B+N4uCBEQeDPWrq/kgpn1+MXLU5Cjn2PM/rL8Acs47cp/F05lwqe+ds7cXww0iP42853HNP/GsTFeJl0",
	"UxlhZLtQ+nJQXT4T3/N+0cK38ZsavWuWPgXFC5ZnF5Qswl88juWmX7kuueRs9uL0aNOHy+Bbm9eVWMP3",
	"nDnoXX2bXR1OD5PVZHvj78gl5OxYoyBEs9vW6HbZ+qmSuZKzF5JT4P3EZZn7i3O7UTjcgcLpMpe4nB05",
	"YzUTnO24OWt2Yf+Uy5I1SuOs+7Xz/iPMX3TuMLhM26YF0134IZS58Vc16xIUktSQ3fFd2ptENZOs9DcJ",
	"22ueXVBupKhIpHXYIZkvh+Cf8BB8baDR47zVxer/AQAA///Vi+Ye6D0AAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
